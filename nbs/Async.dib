#!meta

{"kernelInfo":{"defaultKernelName":"fsharp","items":[]}}

#!markdown

# Async (Polyglot)

#!fsharp

#!import ../nbs/Testing.dib

#!fsharp

#!import ../nbs/Common.fs

#!fsharp

open Common

#!markdown

## choice

#!fsharp

let choice asyncs = async {
    let e = Event<_> ()
    let cts = new System.Threading.CancellationTokenSource ()
    let fn =
        asyncs
        |> Seq.map (fun a -> async {
            let! x = a
            e.Trigger x
        })
        |> Async.Parallel
        |> Async.Ignore
    Async.Start (fn, cts.Token)
    let! result = Async.AwaitEvent e.Publish
    cts.Cancel ()
    return result
}

#!markdown

## map

#!fsharp

let map fn a = async {
    let! x = a
    return fn x
}

#!markdown

## runWithTimeoutAsync

#!fsharp

let runWithTimeoutAsync (timeout : int) fn =
    let getLocals () = $"timeout: {timeout} / {getLocals ()}"

    let timeoutTask = async {
        do! Async.Sleep timeout
        trace Debug (fun () -> "runWithTimeoutAsync") getLocals
        return None
    }

    let task = fn |> map Some

    [ timeoutTask; task ]
    |> choice

#!fsharp

let runWithTimeout timeout fn =
    fn
    |> runWithTimeoutAsync timeout
    |> Async.RunSynchronously

#!fsharp

//// test

Async.Sleep 60
|> runWithTimeout 10
|> _equal None

#!fsharp

//// test

Async.Sleep 10
|> runWithTimeout 60
|> _equal (Some ())

#!markdown

## runWithTimeoutStrict

#!fsharp

let runWithTimeoutStrict (timeout : int) fn =
    let getLocals () = $"timeout: {timeout} / {getLocals ()}"

    let timeoutTask = async {
        do! Async.Sleep timeout
        return None, getLocals
    }
    
    let task = async {
        try
            return Async.RunSynchronously (fn, timeout) |> Some, getLocals
        with
        | :? System.TimeoutException as ex ->
            let getLocals () = $"exception: {ex.Message} / {getLocals ()}"
            return None, getLocals
        | e ->
            trace Error (fun () -> "runWithTimeoutStrict") getLocals
            return raise e
    }

    try
        [| timeoutTask; task |]
        |> Array.map Async.StartAsTask
        |> System.Threading.Tasks.Task.WhenAny
        |> fun task ->
            match task.Result.Result with
            | None, getLocals ->
                trace Debug (fun () -> "runWithTimeoutStrict") getLocals
                None
            | result, _ -> result
    with
    | :? System.AggregateException as ex when
        ex.InnerExceptions
        |> Seq.exists (function | :? System.Threading.Tasks.TaskCanceledException -> true | _ -> false)
        ->
        let getLocals () = $"exception: {ex.Message} / {getLocals ()}"
        trace Warn (fun () -> "runWithTimeoutStrict") getLocals
        None
    | ex ->
        trace Error (fun () -> "runWithTimeoutStrict") getLocals
        raise ex

#!fsharp

//// test

Async.Sleep 60
|> runWithTimeoutStrict 10
|> _equal None

#!fsharp

//// test

Async.Sleep 10
|> runWithTimeoutStrict 60
|> _equal (Some ())

#!markdown

## awaitValueTask

#!fsharp

let awaitValueTaskUnit (task : System.Threading.Tasks.ValueTask) =
    task.AsTask () |> Async.AwaitTask

let awaitValueTask (task : System.Threading.Tasks.ValueTask<_>) =
    task.AsTask () |> Async.AwaitTask
