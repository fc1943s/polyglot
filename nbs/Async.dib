#!meta

{"kernelInfo":{"defaultKernelName":"fsharp","items":[]}}

#!markdown

# Async (Polyglot)

#!fsharp

#!import ../nbs/Testing.dib

#!fsharp

#!import ../nbs/Common.fs

#!fsharp

open Common

#!markdown

## choice

#!fsharp

let inline choice asyncs = async {
    let e = Event<_> ()
    use cts = new System.Threading.CancellationTokenSource ()
    let fn =
        asyncs
        |> Seq.map (fun a -> async {
            let! x = a
            e.Trigger x
        })
        |> Async.Parallel
        |> Async.Ignore
    Async.Start (fn, cts.Token)
    let! result = Async.AwaitEvent e.Publish
    cts.Cancel ()
    return result
}

#!markdown

## map

#!fsharp

let inline map fn a = async {
    let! x = a
    return fn x
}

#!markdown

## runWithTimeoutAsync

#!fsharp

let inline runWithTimeoutAsync (timeout : int) fn =
    let getLocals () = $"timeout: {timeout} / {getLocals ()}"

    let timeoutTask = async {
        do! Async.Sleep timeout
        trace Debug (fun () -> "runWithTimeoutAsync") getLocals
        return None
    }

    let task = async {
        try
            let! result = fn
            return Some result
        with
        | :? System.AggregateException as ex when
            ex.InnerExceptions
            |> Seq.exists (function :? System.Threading.Tasks.TaskCanceledException -> true | _ -> false)
            ->
            let getLocals () = $"ex: {ex |> printException} / {getLocals ()}"
            trace Warn (fun () -> "runWithTimeoutAsync") getLocals
            return None
        | ex ->
            trace Error (fun () -> "runWithTimeoutAsync") getLocals
            return raise ex
    }

    [ timeoutTask; task ]
    |> choice

#!fsharp

let inline runWithTimeout timeout fn =
    fn
    |> runWithTimeoutAsync timeout
    |> Async.RunSynchronously

#!fsharp

//// test

Async.Sleep 60
|> runWithTimeout 10
|> _equal None

#!fsharp

//// test

Async.Sleep 10
|> runWithTimeout 60
|> _equal (Some ())

#!markdown

## runWithTimeoutStrict

#!fsharp

let inline runWithTimeoutStrict (timeout : int) fn =
    let getLocals () = $"timeout: {timeout} / {getLocals ()}"

    let timeoutTask = async {
        do! Async.Sleep timeout
        return None, getLocals
    }
    
    let task = async {
        try
            return Async.RunSynchronously (fn, timeout) |> Some, getLocals
        with
        | :? System.TimeoutException as ex ->
            let getLocals () = $"ex: {ex |> printException} / {getLocals ()}"
            return None, getLocals
        | e ->
            trace Error (fun () -> "runWithTimeoutStrict") getLocals
            return raise e
    }

    try
        [| timeoutTask; task |]
        |> Array.map Async.StartAsTask
        |> System.Threading.Tasks.Task.WhenAny
        |> fun task ->
            match task.Result.Result with
            | None, getLocals ->
                trace Debug (fun () -> "runWithTimeoutStrict") getLocals
                None
            | result, _ -> result
    with
    | :? System.AggregateException as ex when
        ex.InnerExceptions
        |> Seq.exists (function :? System.Threading.Tasks.TaskCanceledException -> true | _ -> false)
        ->
        let getLocals () = $"ex: {ex |> printException} / {getLocals ()}"
        trace Warn (fun () -> "runWithTimeoutStrict") getLocals
        None
    | ex ->
        trace Error (fun () -> "runWithTimeoutStrict") getLocals
        raise ex

#!fsharp

//// test

Async.Sleep 60
|> runWithTimeoutStrict 10
|> _equal None

#!fsharp

//// test

Async.Sleep 10
|> runWithTimeoutStrict 60
|> _equal (Some ())

#!markdown

## awaitValueTask

#!fsharp

let inline awaitValueTaskUnit (task : System.Threading.Tasks.ValueTask) =
    task.AsTask () |> Async.AwaitTask

let inline awaitValueTask (task : System.Threading.Tasks.ValueTask<_>) =
    task.AsTask () |> Async.AwaitTask

#!markdown

## init

#!fsharp

let inline init x = async {
    return x
}

#!fsharp

//// test

init 1
|> Async.RunSynchronously
|> _equal 1

#!markdown

## mergeCancellationTokenWithDefaultAsync

#!fsharp

let inline mergeCancellationTokenWithDefaultAsync (token : System.Threading.CancellationToken) = async {
    let! ct = Async.CancellationToken
    let dct = Async.DefaultCancellationToken
    let cts = System.Threading.CancellationTokenSource.CreateLinkedTokenSource [| ct; dct; token |]
    return cts.Token
}

#!markdown

## withTraceLevel

#!fsharp

let inline withTraceLevel level fn = async {
    let oldTraceLevel = traceLevel
    try
        traceLevel <- level
        return! fn
    finally
        traceLevel <- oldTraceLevel
}
