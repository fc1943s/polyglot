#!meta

{"kernelInfo":{"defaultKernelName":"spiral","items":[]}}

#!markdown

# runtime

#!spiral

open rust_operators
open sm'_operators

#!spiral

//// test

open testing
open file_system_operators

#!markdown

## types

#!spiral

inl types () =
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"clap::Arg\")>]\n#endif\ntype clap_Arg = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"clap::Command\")>]\n#endif\ntype clap_Command = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"clap::ArgMatches\")>]\n#endif\ntype clap_ArgMatches = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"clap::builder::ValueRange\")>]\n#endif\ntype clap_builder_ValueRange = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"clap::builder::ValueParser\")>]\n#endif\ntype clap_builder_ValueParser = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"clap::builder::PossibleValue\")>]\n#endif\ntype clap_builder_PossibleValue = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::process::Child\")>]\n#endif\ntype std_process_Child = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::process::ChildStderr\")>]\n#endif\ntype std_process_ChildStderr = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::process::ChildStdout\")>]\n#endif\ntype std_process_ChildStdout = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::process::ChildStdin\")>]\n#endif\ntype std_process_ChildStdin = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::process::Command\")>]\n#endif\ntype std_process_Command = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::process::Output\")>]\n#endif\ntype std_process_Output = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::process::Stdio\")>]\n#endif\ntype std_process_Stdio = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::sync::mpsc::Receiver<$0>\")>]\n#endif\ntype std_sync_mpsc_Receiver<'T> = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::sync::mpsc::Sender<$0>\")>]\n#endif\ntype std_sync_mpsc_Sender<'T> = class end"

#!spiral

inl types () =
    rust.types ()
    sm'.types ()
    am'.types ()
    async.types ()
    seq.types ()
    threading.types ()
    types ()

#!spiral

//// test

inl types () =
    file_system.types ()
    types ()

#!markdown

## child

#!spiral

nominal child = $'std_process_Child'

#!markdown

## child_stderr

#!spiral

nominal child_stderr = $"std_process_ChildStderr"

#!markdown

## child_stdout

#!spiral

nominal child_stdout = $"std_process_ChildStdout"

#!markdown

## child_stdin

#!spiral

nominal child_stdin = $"std_process_ChildStdin"

#!markdown

## process_command

#!spiral

nominal process_command = $'std_process_Command'

#!markdown

## stdio

#!spiral

nominal stdio = $'std_process_Stdio'

#!markdown

## output

#!spiral

nominal output = $'std_process_Output'

#!markdown

## receiver

#!spiral

nominal receiver t = $'std_sync_mpsc_Receiver<`t>'

#!markdown

## sender

#!spiral

nominal sender t = $'std_sync_mpsc_Sender<`t>'

#!markdown

## os_platform

#!spiral

nominal os_platform' = $'System.Runtime.InteropServices.OSPlatform'

union os_platform =
    | Windows

inl os_platform = function
    | Windows => $'`os_platform'.Windows' : os_platform'

#!markdown

## is_os_platform

#!spiral

inl is_os_platform (x : os_platform') : bool =
    x |> $'System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform'

#!markdown

## is_windows

#!spiral

inl is_windows () : bool =
    run_target function
        | Fsharp (Native) => fun () =>
            Windows |> os_platform |> is_os_platform
        | Rust (Native) => fun () =>
            !\($'"cfg\!(windows)"')
        | _ => fun () => null ()

#!markdown

## get_executable_suffix

#!spiral

inl get_executable_suffix () =
    if is_windows ()
    then ".exe"
    else ""

#!spiral

//// test

get_executable_suffix ()

#!markdown

## quoted

#!spiral

union quoted =
    | Quoted
    | NotQuoted

#!markdown

## split_command

#!spiral

union command_parse_step =
    | Start
    | Path : quoted
    | Arguments

inl split_command (command : string) =
    let rec loop (path, args) (chars : list char) step =
        match step, chars with
        | _, (('"' | '\'') :: tail) when path = "" => loop (path, args) tail (Path Quoted)
        | Path (Quoted), (('"' | '\'') :: tail) => loop (path, args) tail (Path NotQuoted)
        | Path (Quoted), (' ' :: tail) => loop ($'$"{!path} "', args) tail (Path Quoted)
        | (Start | Path _), (' ' :: tail) => loop (path, args) tail Arguments
        | Arguments, (char :: tail) => loop (path, $'$"{!args}{!char}"') tail Arguments
        | _, (char :: tail) => loop ($'$"{!path}{!char}"', args) tail step
        | _ => path |> sm'.replace @"\" "/", args
    loop (join "", "") (command |> sm'.to_char_array |> am'.to_list' |> listm'.unbox) Start

#!spiral

//// test

split_command ""
|> _assert_eq ("", "")

split_command "/a/b/c"
|> _assert_eq ("/a/b/c", "")

split_command "cat file.txt"
|> _assert_eq ("cat", "file.txt")

split_command $'"""..\\..\\file.exe file1.txt file2.txt"""'
|> _assert_eq ("../../file.exe", "file1.txt file2.txt")

split_command $'\@"c:\\dir\\file.exe ""file1.txt file2.txt"""'
|> _assert_eq ("c:/dir/file.exe", $'\@"""file1.txt file2.txt"""')

split_command $'\@"""..\\..\\dir name\\file.exe"" ""file 1.txt"" file2.txt"'
|> _assert_eq ("../../dir name/file.exe", $'\@"""file 1.txt"" file2.txt"')

split_command $'\@"""..\\..\\file 1.exe"" -c \\\\""echo 1\\\\"""'
|> _assert_eq ("../../file 1.exe", $'\@"-c \\\\""echo 1\\\\"""')

split_command $'\@"..\\..\\file 1.exe -c \\\\""echo 1\\\\"""'
|> _assert_eq ("../../file", $'\@"1.exe -c \\\\""echo 1\\\\"""')

#!markdown

## process

#!spiral

nominal process = $'System.Diagnostics.Process'
nominal process_start_info = $'System.Diagnostics.ProcessStartInfo'
nominal data_received_event_args = $'System.Diagnostics.DataReceivedEventArgs'

inl new_process (process_start_info : process_start_info) : process =
    $'new `process (StartInfo = !process_start_info)'

inl process_start (process : process) : bool =
    $'!process.Start' ()

inl process_exit_code (process : process) : i32 =
    $'!process.ExitCode'

inl process_id (process : process) : i32 =
    $'!process.Id'

inl process_has_exited (process : process) : bool =
    run_target function
        | Fsharp (Native) => fun () =>
            $'!process.HasExited'
        | _ => fun () => null ()

inl process_kill (process : process) : () =
    run_target function
        | Fsharp (Native) => fun () =>
            $'!process.Kill' ()
        | _ => fun () => null ()

inl process_begin_error_read_line (process : process) : () =
    $'!process.BeginErrorReadLine' ()

inl process_begin_output_read_line (process : process) : () =
    $'!process.BeginOutputReadLine' ()

inl process_add_output_data_received fn (process : process) : () =
    $'!process.OutputDataReceived.Add !fn '

inl process_add_error_data_received fn (process : process) : () =
    $'!process.ErrorDataReceived.Add !fn '

inl process_wait_for_exit_async (ct : threading.cancellation_token) (process : process) : async.task () =
    $'!process.WaitForExitAsync !ct '

inl event_data (e : data_received_event_args) : string =
    $'!e.Data'

#!markdown

## execution_line

#!spiral

type execution_line =
    {
        process_id : int
        line : string
        error : bool
    }

#!markdown

## execution_options

#!spiral

type execution_options =
    {
        command : string
        working_directory : optionm'.option' string
        cancellation_token : optionm'.option' threading.cancellation_token
        environment_variables : array_base (string * string)
        on_line : optionm'.option' (execution_line -> async.async ())
        stdin : optionm'.option' (threading.arc (threading.mutex child_stdin) -> ())
    }

inl execution_options (fn : execution_options -> execution_options) : execution_options =
    {
        command = ""
        working_directory = None |> optionm'.box
        cancellation_token = None |> optionm'.box
        environment_variables = ;[]
        on_line = None |> optionm'.box
        stdin = None |> optionm'.box
    }
    |> fn

#!markdown

## execute_with_options_async

#!spiral

inl execute_with_options_async (options : execution_options) : _ (i32 * string) =
    run_target function
        | Fsharp (Native) => fun () =>
            fun () =>
                inl file_name, arguments = options.command |> split_command
                inl working_directory = options.working_directory |> optionm'.unbox |> optionm'.default_value ""

                trace Debug (fun () => $'$"execute_with_options_async / options: %A{!options}"') (join _locals)

                inl utf8 = sm'.encoding_utf8 ()
                inl start_info : process_start_info = $'System.Diagnostics.ProcessStartInfo (Arguments = !arguments, StandardOutputEncoding = !utf8, WorkingDirectory = !working_directory, FileName = !file_name, CreateNoWindow = true, RedirectStandardError = true, RedirectStandardOutput = true, UseShellExecute = false)'

                (a options.environment_variables : _ i32 _)
                |> am.iter fun key, value =>
                    $'!start_info.EnvironmentVariables.[!key] <- !value '

                inl proc = start_info |> new_process |> use
                inl output : _ string = threading.new_concurrent_stack ()

                inl event error (e : data_received_event_args) = async.new_async fun () =>
                    inl data = e |> event_data
                    if data <> null () then
                        match options.on_line |> optionm'.unbox with
                        | Some on_line =>
                            on_line
                                {
                                    process_id = proc |> process_id
                                    line = data
                                    error = error
                                }
                            |> async.do
                        | None => ()

                        trace Verbose (fun () => $'$"> {!data}"') _locals

                        inl l = if error then "[" else ""
                        inl r = if error then "]" else ""
                        output |> threading.concurrent_stack_push $'$"{!l}{!data}{!r}"'

                proc |> process_add_output_data_received (event false >> async.start_immediate)
                proc |> process_add_error_data_received (event true >> async.start_immediate)

                if proc |> process_start |> not
                then failwith $'$"execute_with_options_async / process_start error"'

                proc |> process_begin_error_read_line
                proc |> process_begin_output_read_line

                inl ct =
                    options.cancellation_token
                    |> optionm'.unbox
                    |> optionm'.default_with threading.token_none
                    |> async.merge_cancellation_token_with_default_async
                    |> async.let'

                ct |> threading.token_register fun () =>
                    if proc |> process_has_exited |> not
                    then proc |> process_kill
                |> use
                |> ignore

                inl exit_code : i32 =
                    fun () =>
                        try_unit
                            fun () =>
                                proc
                                |> process_wait_for_exit_async ct
                                |> async.await_task
                                |> async.do
                                proc |> process_exit_code |> return
                            fun ex =>
                                // with :? System.Threading.Tasks.TaskCanceledException as ex =>
                                inl ex' = ex |> sm'.format_exception
                                output |> threading.concurrent_stack_push ex'
                                inl ex : async.task_canceled_exception = ex |> unbox
                                trace Warning (fun () => $'$"execute_with_options_async / WaitForExitAsync / ex: %A{!ex}"') (join _locals)
                                (limit.min : i32) |> return
                    |> async.new_async_unit
                    |> async.let'

                inl output =
                    output
                    |> seq.rev''
                    |> fun x => x : seq.seq' string
                    |> sm'.concat "\n"

                trace Debug (fun () =>
                    $'$"execute_with_options_async / exit_code: {!exit_code} / output.Length: {!output.Length}"'
                ) (join _locals)

                (exit_code, output) |> return
            |> async.new_async_unit
        | _ => fun () =>
            global "#if FABLE_COMPILER\n[<CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>]\nmodule System =\n module Diagnostics =\n  type Process = unit\n  type DataReceivedEventArgs = unit\n#endif"
            null ()

#!markdown

## execute_async

#!spiral

inl execute_async command =
    execution_options fun x => { x with
        command = command
    }
    |> execute_with_options_async

#!spiral

//// test

types ()
inl temp_folder, disposable = file_system.create_temp_directory ()
disposable |> use |> ignore
inl file_name = "test.txt"
inl path = temp_folder </> file_name

fun () =>
    inl exit_code, result = execute_async $'\@$"pwsh -c ""Get-Content {!path}"""' |> async.let'
    exit_code |> join _assert_eq 1
    result |> _assert_string_contains "not exist"

    "0" |> file_system.write_all_text_async path |> async.do

    execution_options fun x => { x with
        command = $'\@$"pwsh -c ""Get-Content {!file_name}"""'
        working_directory = Some temp_folder |> optionm'.box
    }
    |> execute_with_options_async
    |> async.return_await
|> async.new_async_unit
|> async.run_with_timeout 10000
|> function
    | Some (exit_code, output) =>
        exit_code |> join _assert_eq 0i32
        output |> join _assert_eq "0"
        true
    | _ => false
|> _assert_eq true

#!spiral

//// test

file_system.types ()
inl temp_dir, disposable = file_system.create_temp_directory ()
disposable |> use |> ignore
fun () =>
    inl path = temp_dir </> "test.txt"
    "0" |> file_system.write_all_text_async path |> async.do

    inl cts = threading.new_cancellation_token_source ()
    trace Debug (fun () => "1") _locals
    inl result =
        execution_options fun x => { x with
            command = $'\@$"pwsh -c ""Get-Content {!path}"""'
            cancellation_token = cts |> threading.cancellation_source_token |> Some |> optionm'.box
        }
        |> execute_with_options_async
        |> async.start_child
        |> async.let'
    trace Debug (fun () => "2") _locals
    async.sleep 100 |> async.do
    trace Debug (fun () => "3") _locals
    cts |> threading.cancellation_source_cancel
    trace Debug (fun () => "4") _locals
    inl exit_code, output = result |> async.let'
    trace Debug (fun () => "5") _locals
    (exit_code, output) |> return
|> async.new_async_unit
|> async.run_with_timeout 10000
|> function
    | Some (exit_code, output) =>
        exit_code |> _assert_eq -2147483648i32
        output |> _assert_eq (join "System.Threading.Tasks.TaskCanceledException: A task was canceled.")
        true
    | _ => false
|> _assert_eq true

#!markdown

## split_args

#!spiral

union args_parse_step =
    | Start
    | Quoted : char
    | Escaped : u8

let split_args (args : string) : array_base string =
    let rec loop (acc, current) (chars : list char) (step, last) =
        // trace Verbose (fun () => $'$"split_args / current: %A{!current} / acc: %A{!acc} / step: %A{!step} / last: %A{!last}"') _locals
        match step, chars with
        | Start, ('"' :: tail) =>
            loop (acc, "") tail (Quoted '"', step)
        | Escaped _, ('\\' :: tail) =>
            loop (acc, current) tail (Quoted '\\', step)
        | Escaped _, ('"' :: tail) when last = Start =>
            loop (acc, current) tail (step, step)
        | Quoted ('"'), ('"' :: tail) when last =. Quoted '\\' =>
            loop (acc, current) tail (Start, step)
        | Quoted ('\\'), ('"' :: tail) when last <>. Escaped 0 =>
            loop (acc, $'$"{!current}\\\""') tail (Quoted '"', step)
        | Quoted ('\\'), ('"' :: tail) when last =. Quoted '\\' =>
            loop (acc, $'$"{!current}\\\""') tail (Quoted '"', step)
        | Quoted ('\\'), ('"' :: tail) =>
            loop (acc, current) tail (Start, step)
        | Escaped n, ('"' :: tail) =>
            loop (acc, $'$"{!current}\\\""') tail (Escaped n, step)
        | Quoted _, ('\\' :: tail) =>
            loop (acc, current) tail (Escaped 1, step)
        | Quoted _, ('"' :: tail) when last =. Escaped 0 =>
            loop (acc, $'$"{!current}\\\""') tail (Quoted '"', step)
        | Quoted _, ('"' :: tail) =>
            loop (acc /@ [ current ], "") tail (Start, step)
        | (Escaped _ | Quoted _), (' ' :: tail) =>
            loop (acc, $'$"{!current} "') tail (step, step)
        | _, ('\\' :: tail) =>
            loop (acc, current) tail (Escaped 0, step)
        | _, (' ' :: tail) =>
            loop ((if current = "" then acc else acc /@ [ current ]), "") tail (step, step)
        | Escaped (1), (char :: tail) when last <>. step =>
            loop (acc, $'$"{!current}\\{!char}"') tail (last, step)
        | _, (char :: tail) =>
            loop (acc, $'$"{!current}{!char}"') tail (step, step)
        | _ =>
            (if current = "" then acc else acc /@ [ current ]), current
    loop
        ([], "")
        (
            args
            |> optionm'.of_obj
            |> optionm'.unbox
            |> optionm'.default_value ""
            |> sm'.to_char_array
            |> am'.to_list'
            |> listm'.unbox
        )
        (Start, Start)
    |> fst
    |> listm'.box
    |> listm'.to_array'
    |> fun (a x : _ i32 _) => x

#!spiral

//// test
//// print_code=false

"a b \"c d\" e"
|> split_args
|> _assert_eq' ;[ "a"; "b"; "c d"; "e" ]

#!spiral

//// test
//// print_code=false

"a b e"
|> split_args
|> _assert_eq' ;[ "a"; "b"; "e" ]

#!spiral

//// test
//// print_code=false

"\"a b\" \"e\" \"f\""
|> split_args
|> _assert_eq' ;[ "a b"; "e"; "f" ]

#!spiral

//// test
//// print_code=false

"a -b \"c \\\"d\\\"\""
|> split_args
|> _assert_eq' ;[ "a"; "-b"; "c \"d\"" ]

#!spiral

//// test
//// print_code=false

"a -b \"c \\\"d\\\" e\""
|> split_args
|> _assert_eq' ;[ "a"; "-b"; "c \"d\" e" ]

#!spiral

//// test
//// print_code=false

$'$"--text \\\\\\"\'\'\' value \'\'\'\\\\\\" "'
|> split_args
|> _assert_eq' ;[ "--text"; "''' value '''" ]

#!spiral

//// test
//// print_code=false

$'\@$"run ""get c:\\test.txt"""'
|> split_args
|> _assert_eq' ;[ "run"; "get c:\\test.txt" ]

#!markdown

## stdin_write_all

#!spiral

inl stdin_write_all (stdin : threading.mutex_guard child_stdin) (text : string) : () =
    inl stream = text |> sm'.as_bytes
    inl stdin = join stdin
    (!\($'"true; let mut !stdin = !stdin"') : bool) |> ignore
    (!\\(stdin, $'"true; std::io::Write::write_all(&mut *$0, !stream).unwrap()"') : bool) |> ignore

#!markdown

## stdin_flush

#!spiral

inl stdin_flush (stdin : threading.mutex_guard child_stdin) : () =
    inl stdin = join stdin
    (!\($'"true; let mut !stdin = !stdin"') : bool) |> ignore
    (!\\(stdin, $'"true; std::io::Write::flush(&mut *$0).unwrap()"') : bool) |> ignore

#!markdown

## execute_with_options

#!spiral

inl execute_with_options (options : execution_options) : i32 * string =
    run_target function
        | Fsharp (Native) => fun () =>
            options |> execute_with_options_async |> async.run_synchronously
        | Rust (Native) => fun () =>
            inl command = join options.command
            inl file_name, arguments = command |> split_command
            inl arguments =
                arguments
                |> split_args
                |> am'.to_vec
                |> am'.vec_map sm'.to_std_string

            trace Debug (fun () => $'$"execute_with_options / file_name: {!file_name} / arguments: %A{!arguments} / options: %A{!options}"') (join _locals)

            fun () =>
                inl command : process_command = !\\(file_name, $'"std::process::Command::new(&*$0)"')

                (!\($'"true; let mut !command = !command"') : bool) |> ignore
                inl command : rust.ref' (rust.mut' process_command) = !\\((command, arguments), $'"std::process::Command::args(&mut $0, &*$1)"')

                (!\($'"true; let mut !command = !command"') : bool) |> ignore
                inl command : rust.ref' (rust.mut' process_command) = !\\(command, $'"std::process::Command::stdout(&mut $0, std::process::Stdio::piped())"')

                (!\($'"true; let mut !command = !command"') : bool) |> ignore
                inl command : rust.ref' (rust.mut' process_command) = !\\(command, $'"std::process::Command::stderr(&mut $0, std::process::Stdio::piped())"')

                (!\($'"true; let mut !command = !command"') : bool) |> ignore
                inl command : rust.ref' (rust.mut' process_command) = !\\(command, $'"std::process::Command::stdin(&mut $0, std::process::Stdio::piped())"')

                inl command =
                    match options.working_directory |> optionm'.unbox with
                    | Some working_directory =>
                        inl working_directory = join working_directory
                        !\($'"std::process::Command::current_dir(!command, &*!working_directory)"')
                    | None => command

                (!\($'"true; let mut !command = !command"') : bool) |> ignore
                inl command : resultm.result' child stream.io_error = !\\(command, $'"std::process::Command::spawn(&mut $0)"')

                match command |> resultm.map' (optionm'.some' >> threading.new_arc_mutex) |> resultm.map_error' sm'.format' |> resultm.unbox with
                | Ok child =>
                    inl child = join child
                    inl stdout : child_stdout = !\($'"!child.lock().unwrap().as_mut().unwrap().stdout.take().unwrap()"')
                    inl stderr : child_stderr = !\($'"!child.lock().unwrap().as_mut().unwrap().stderr.take().unwrap()"')
                    inl stdin : child_stdin = !\($'"!child.lock().unwrap().as_mut().unwrap().stdin.take().unwrap()"')
                    inl stdout = stdout |> optionm'.some' |> threading.new_arc_mutex
                    inl stderr = stderr |> optionm'.some' |> threading.new_arc_mutex
                    inl stdin = stdin |> optionm'.some' |> threading.new_arc_mutex

                    inl channel_sender, channel_receiver : sender sm'.std_string * threading.arc (receiver sm'.std_string) =
                        !\($'"{ let (sender, receiver) = std::sync::mpsc::channel(); (sender, std::sync::Arc::new(receiver)) }"')
                    inl channel_receiver = join channel_receiver
                    (!\\(channel_receiver, $'"true; let !channel_receiver = !channel_receiver"') : bool) |> ignore

                    inl channel_sender = channel_sender |> threading.new_arc_mutex
                    inl channel_sender' = channel_sender |> rust.clone
                    inl channel_sender'' = channel_sender |> rust.clone
                    inl channel_receiver' = channel_receiver |> threading.new_arc_mutex

                    inl std_line (stdout : bool) channel_sender (line : _ _ stream.io_error) =
                        inl line =
                            match line |> resultm.map_error' sm'.format' |> resultm.unbox with
                            | Ok (line : sm'.std_string) =>
                                trace Verbose (fun () => $'$"> {!line}"') _locals
                                line
                            | Error (e : sm'.std_string) =>
                                trace Critical (fun () => $'$"execute_with_options / stdout_line / stdout: {!stdout} / e: {!e}"') _locals
                                $'$"[{!e}]"' |> sm'.to_std_string
                        (!\\((channel_sender, line), $'"true; $0.lock().unwrap().send($1).unwrap()"') : bool) |> ignore

                    inl stdout_thread : threading.join_handle () = !\($'"std::thread::spawn(move || { //"')
                    inl stdout' : child_stdout = !\($'"!stdout.lock().unwrap().take().unwrap()"')
                    inl stdout_lines =
                        stdout'
                        |> stream.new_buf_reader
                        |> stream.buf_read_lines
                        |> threading.new_arc_mutex
                    inl std_line' = std_line true channel_sender'
                    inl std_line' = join std_line'
                    (!\\(stdout_lines, $'"true; for line in $0.lock().unwrap().by_ref() { !std_line'(line) }"') : bool) |> ignore
                    (!\($'"true; })"') : bool) |> ignore

                    inl stderr_thread : threading.join_handle () = !\($'"std::thread::spawn(move || { //"')
                    inl stderr' : child_stderr = !\($'"!stderr.lock().unwrap().take().unwrap()"')
                    inl stderr_lines =
                        stderr'
                        |> stream.new_buf_reader
                        |> stream.buf_read_lines
                        |> threading.new_arc_mutex
                    inl std_line' = std_line false channel_sender
                    inl std_line' = join std_line'
                    (!\\(stderr_lines, $'"true; for line in $0.lock().unwrap().by_ref() { !std_line'(line) }"') : bool) |> ignore
                    (!\($'"true; })"') : bool) |> ignore
                    
                    match options.stdin |> optionm'.unbox with
                    | Some stdin' =>
                        inl stdin : optionm'.option' child_stdin =
                            !\($'"!stdin.lock().unwrap().take()"')
                        match stdin |> optionm'.map' threading.new_arc_mutex |> optionm'.unbox with
                        | Some stdin =>
                            stdin |> stdin'
                            stdin
                            |> threading.arc_mutex_lock
                            |> resultm.unwrap'
                            |> stdin_flush
                            // (!\\(stdin, $'"true; std::io::Write::write_all(&mut *$0.lock().unwrap(), !stream).unwrap()"') : bool) |> ignore
                            // (!\($'"true; let mut !stdin = !stdin"') : bool) |> ignore
                            // (!\\(stdin, $'"true; std::io::Write::flush(&mut *$0.lock().unwrap()).unwrap()"') : bool) |> ignore
                            // stdin |> rust.drop
                            // (!\($'"true; *!stdin.lock().unwrap() = Some(!stdin')"') : bool) |> ignore
                            // stdin |> rust.drop
                        | None => ()
                    | None => ()

                    inl output : resultm.result' output stream.io_error = !\($'"!child.lock().unwrap().take().unwrap().wait_with_output()"')
                    inl output = output |> resultm.map_error' sm'.format'

                    (!\($'"true; !stdout_thread.join().unwrap()"') : bool) |> ignore
                    (!\($'"true; !stderr_thread.join().unwrap()"') : bool) |> ignore

                    match output |> resultm.unbox with
                    | Ok output =>
                        inl exit_code : i32 = !\\(output, $'"$0.status.code().unwrap()"')
                        exit_code, None, Some channel_receiver'
                    | Error error =>
                        trace Critical (fun () => $'$"execute_with_options -2 / error: {!error}"') _locals
                        -2i32, error |> Some, None
                | Error error =>
                    trace Critical (fun () => $'$"execute_with_options -1 / error: {!error}"') _locals
                    -1i32, error |> Some, None
                |> function
                    | exit_code, std_trace, channel_receiver =>
                        inl std_trace =
                            channel_receiver
                            |> optionm.map fun channel_receiver =>
                                !\\(channel_receiver, $'"$0.lock().unwrap().iter().collect::<Vec<String>>().join(\\"\\\\n\\")"')
                            |> optionm.map sm'.from_std_string
                            |> optionm'.default_value (
                                std_trace
                                |> optionm.map sm'.from_std_string
                                |> optionm'.default_value ""
                            )
                        trace Verbose (fun () => $'$"execute_with_options / exit_code: {!exit_code} / std_trace.Length: {!std_trace.Length}"') _locals
                        new_pair exit_code std_trace
            |> async.future_init (3, 2) 1
            |> async.block_on
            |> from_pair
        | _ => fun () => null ()

#!spiral

inl execute command =
    execution_options fun x => { x with
        command = command
    }
    |> execute_with_options

#!spiral

//// test
//// print_code=false
///! rust

types ()
inl temp_folder, disposable = file_system.create_temp_directory ()
fun () =>
    inl file_name = join "test.txt"
    inl path = temp_folder </> file_name
    inl exit_code, result = execute $'\@$"pwsh -c ""Get-Content {!path}"""'
    exit_code |> _assert_eq 1
    result |> _assert_string_contains "not exist"

    "0" |> file_system.write_all_text path

    execution_options fun x => { x with
        command = $'\@$"pwsh -c ""Get-Content {!file_name}"""'
        working_directory = Some temp_folder |> optionm'.box
    }
    |> execute_with_options
|> fun fn => fn () |> Some
|> function
    | Some (exit_code, output) =>
        exit_code |> _assert_eq 0i32
        output |> _assert_eq (join "0")
        true
    | _ => false
|> _assert_eq true
disposable |> use |> ignore

#!markdown

## command

#!spiral

nominal command = $'clap_Command'

#!markdown

## new_command

#!spiral

inl new_command (s : rust.static_ref' sm'.str) : command =
    !\\(s, $'"clap::Command::new($0)"')

#!spiral

//// test
//// print_code=false
///! rust

types ()
##"command"
|> new_command
|> sm'.format_pretty'
|> sm'.from_std_string
|> _assert_string_contains "command"

#!markdown

## arg

#!spiral

nominal arg = $'clap_Arg'

#!markdown

## new_arg

#!spiral

inl new_arg (s : rust.static_ref' sm'.str) : arg =
    !\\(s, $'"clap::Arg::new($0)"')

#!spiral

//// test
//// print_code=false
///! rust

types ()
##"arg"
|> new_arg
|> sm'.format_pretty'
|> sm'.from_std_string
|> _assert_string_contains "arg"

#!markdown

## command_arg

#!spiral

inl command_arg (arg : arg) (command : command) : command =
    !\\((command, arg), $'"clap::Command::arg($0, $1)"')

#!markdown

## arg_required

#!spiral

inl arg_required (value : bool) (arg : arg) : arg =
    !\\((arg, value), $'"$0.required($1)"')

#!markdown

## arg_short

#!spiral

inl arg_short (value : char) (arg : arg) : arg =
    !\\((arg, value), $'"$0.short($1)"')

#!markdown

## arg_long

#!spiral

inl arg_long (value : rust.static_ref' sm'.str) (arg : arg) : arg =
    !\\((arg, value), $'"$0.long($1)"')

#!markdown

## arg_value_names

#!spiral

inl arg_value_names (values : array_base (rust.static_ref' sm'.str)) (arg : arg) : arg =
    inl values = values |> am'.to_vec
    !\\((arg, values), $'"$0.value_names($1)"')

#!markdown

## arg_num_args

#!spiral

inl arg_num_args (value : i32) (arg : arg) : arg =
    !\\((arg, value), $'"$0.num_args($1)"')

#!markdown

## value_range

#!spiral

nominal value_range = $'clap_builder_ValueRange'

#!markdown

## new_value_range

#!spiral

inl new_value_range start end : value_range =
    inl len = -1
    inl start, end =
        open am'
        match start, end with
        | Start start, End fn =>
            start, len |> fn
        | End start_fn, End end_fn =>
            start_fn len, end_fn len
    match start, end with
    | start, end when end = len => !\($'"clap::builder::ValueRange::new(!start..)"')
    | start, end => !\($'"clap::builder::ValueRange::new(!start..!end)"')

#!markdown

## arg_num_args_range

#!spiral

inl arg_num_args_range (value : value_range) (arg : arg) : arg =
    !\\((arg, value), $'"$0.num_args($1)"')

#!markdown

## arg_value_name

#!spiral

inl arg_value_name (value : string) (arg : arg) : arg =
    inl value = value |> sm'.as_str
    !\\((arg, value), $'"$0.value_name($1)"')

#!markdown

## value_parser

#!spiral

nominal value_parser = $'clap_builder_ValueParser'

#!markdown

## possible_value

#!spiral

nominal possible_value = $'clap_builder_PossibleValue'

#!markdown

## new_possible_value

#!spiral

inl new_possible_value forall t. (x : t) : possible_value =
    !\\(x, $'"clap::builder::PossibleValue::new(&**$0)"')

#!markdown

## value_parser_possible_values

#!spiral

inl value_parser_possible_values (values : array_base string) : value_parser =
    inl values =
        values
        |> am'.to_vec
        |> am'.vec_map (sm'.to_std_string >> rust.new_box >> rust.box_leak >> new_possible_value)
    !\\(values, $'"clap::builder::PossibleValuesParser::new($0).into()"')

#!markdown

## arg_value_parser

#!spiral

inl arg_value_parser (values : value_parser) (arg : arg) : arg =
    !\\((arg, values), $'"$0.value_parser($1)"')

#!markdown

## arg_index

#!spiral

inl arg_index (value : i32) (arg : arg) : arg =
    !\\((arg, value), $'"$0.index($1)"')

#!markdown

## arg_matches

#!spiral

nominal arg_matches = $'clap_ArgMatches'

#!markdown

## command_get_matches

#!spiral

inl command_get_matches (command : command) : arg_matches =
    !\\(command, $'"clap::Command::get_matches($0)"')

#!markdown

## command_get_matches_from

#!spiral

inl command_get_matches_from (args : array_base string) (command : command) : arg_matches =
    inl args = args |> am'.to_vec |> am'.vec_map sm'.to_std_string
    !\\(command, $'"clap::Command::get_matches_from($0, !args)"')

#!markdown

## matches_get_one

#!spiral

inl matches_get_one (x : string) (matches : arg_matches) : optionm'.option' sm'.std_string =
    inl x = join x
    inl x = x |> sm'.as_str
    !\($'"clap::ArgMatches::get_one(&!matches, !x).cloned()"')

#!markdown

## matches_get_flag

#!spiral

inl matches_get_flag (x : string) (matches : arg_matches) : bool =
    inl x = join x
    inl x = x |> sm'.as_str
    !\($'"clap::ArgMatches::get_flag(&!matches, !x)"')

#!markdown

## matches_get_many

#!spiral

inl matches_get_many forall t. (x : string) (matches : arg_matches) : optionm'.option' (am'.vec t) =
    inl x = join x
    inl x = x |> sm'.as_str
    !\\(matches, $'"clap::ArgMatches::get_many(&$0, !x).map(|x| x.cloned().into_iter().collect())"')

#!markdown

## matches_get_occurrences

#!spiral

inl matches_get_occurrences (x : string) (matches : arg_matches) : optionm'.option' (array_base sm'.std_string) =
    inl x = join x
    inl x = x |> sm'.as_str
    !\($'"clap::ArgMatches::get_occurrences(&!matches, !x).cloned()"')

#!markdown

## matches_subcommand

#!spiral

inl matches_subcommand (matches : arg_matches) : optionm'.option' (sm'.std_string * arg_matches) =
    open sm'
    inl matches = matches |> rust.clone
    !\\(ref_to_std_string, $'"clap::ArgMatches::subcommand(Box::leak(Box::new(!matches))).map(|(a, b)| ($0(a), b.clone()))"')

#!markdown

## matches_values_of

#!spiral

inl matches_values_of (x : string) (matches : arg_matches) : array_base sm'.std_string =
    !\\((matches, x), $'"clap::ArgMatches::values_of($0, &*$1)"')

#!markdown

## command_debug_assert

#!spiral

inl command_debug_assert (command : command) : () =
    !\\(command, $'"clap::Command::debug_assert($0)"')

#!markdown

## command_subcommand_required

#!spiral

inl command_subcommand_required (value : bool) (command : command) : command =
    !\\(command, $'"clap::Command::subcommand_required($0, !value)"')

#!markdown

## command_subcommand

#!spiral

inl command_subcommand (subcommand : command) (command : command) : command =
    !\\(command, $'"clap::Command::subcommand($0, !subcommand)"')

#!markdown

## main

#!spiral

inl main () =
    types ()
    init_trace_state ()
    $"let is_windows () = !is_windows ()" : ()
    $"let get_executable_suffix () = !get_executable_suffix ()" : ()
    $"let execute_async x = !execute_async x" : ()
    $"let execute_with_options_async x = !execute_with_options_async x" : ()
    inl execution_options fn =
        execution_options fun x =>
            x
            |> heap
            |> fn
            |> fun x => !x
    $"let execution_options x = !execution_options x" : ()
    $"let split_args x = !split_args x" : ()
