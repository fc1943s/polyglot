// // # util

// // ## take_while

inl take_while cond sts =
    inl rec loop acc i =
        inl st = sts i
        if cond st i
        then loop (st :: acc) (i + 1)
        else acc |> listm.rev
    loop [] 0i32

// // ## take_while_

inl take_while_ cond sts =
    let rec loop acc i =
        inl st = sts i
        if cond st i
        then loop (st :: acc) (i + 1)
        else acc |> listm.rev
    loop [] 0i32

// // ## take_while__

inl take_while__ cond sts =
    inl result = mut []
    inl i = mut 0i32
    let rec loop () =
        inl st = sts *i
        if cond st *i then
            result <- st :: *result
            i <- *i + 1
            loop ()
        else *result |> listm.rev
    loop ()

// // ## iterate

inl iterate f x0 num_steps =
    inl rec loop x n =
        if n <= 0
        then x
        else loop (f x) (n - 1)
    loop x0 num_steps

inl iterate_ f x0 num_steps =
    let rec loop x n =
        if n <= 0
        then x
        else loop (f x) (n - 1)
    loop x0 num_steps

inl iterate' f x0 num_steps =
    listm.init num_steps id
    |> listm.fold (fun x _ => f x) x0
