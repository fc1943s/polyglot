/// # base

/// ## arithmetic

/// ### (+.)
inl (+.) forall t. (a : t) (b : t) : t =
    $'!a + !b '

/// ### (-.)
inl (-.) forall t. (a : t) (b : t) : t =
    $'!a - !b '

/// ### (*.)
inl (*.) forall t. (a : t) (b : t) : t =
    $'!a * !b '

/// ### (/.)
inl (/.) forall t. (a : t) (b : t) : t =
    $'!a / !b '

/// ## comparison

/// ### (=.)
inl (=.) forall t. (a : t) (b : t) : bool =
    $'!a = !b '

/// ### (<>.)
inl (<>.) forall t. (a : t) (b : t) : bool =
    $'!a <> !b '

/// ## composition

/// ### append
prototype append t : t -> t -> t

/// ### (++)
inl (++) a b =
    b |> append a

/// ## application

/// ### (||>)
inl (||>) (arg1, arg2) fn =
    arg2 |> fn arg1

/// ## logic

/// ### not_join
inl not_join x =
    join not x

/// ### fix_condition
inl fix_condition x a b =
    if x ()
    then a () |> fun x => $'(*' : ()
    else
        $'*) else' : ()
        b () |> fun x => $'(*' : ()
    |> fun x => $'*)' : ()

/// ## type

/// ### infer
nominal infer = $'_'

/// ### any
nominal any = $'obj'

/// ### null
inl null forall t. () : t =
    $'null |> unbox<`t>'

/// ### defaultof
inl defaultof forall t. () : t =
    $'Unchecked.defaultof<`t>'

/// ## execution

/// ### emit
inl emit forall t. (x : t) : t =
    $'!x '

/// ### emit_unit
inl emit_unit forall t. (x : t) : () =
    $'!x '

/// ### use
inl use forall t. (x : t) : t =
    $'use !x = !x ' : ()
    $'!x '

/// ## function

/// ### invoke
inl invoke fn =
    fn ()

/// ### capture
inl capture forall t. (fn : () -> t) : t =
    inl result = dyn true
    $'let mutable _!result : `t option = None '
    $'('
    $'(fun () ->'
    $'(fun () ->'
    fn () |> emit_unit
    $')'
    $'|> fun x -> x ()'
    $') () )'
    $'|> fun x -> _!result <- Some x'
    $'match _!result with Some x -> x | None -> failwith "base.capture / _!result=None"'

/// ### memoize
nominal lazy t = $'Lazy<`t>'

inl memoize forall t. (fn : () -> t) : () -> t =
    inl fn = join fn
    inl result : lazy t = $'lazy !fn ()'
    fun () => $'!result.Value'

/// ## pair

/// ### pair
nominal pair a b = $'(`a * `b)'

inl pair x y =
    x, y

/// ### new_pair
inl new_pair forall a b. (a : a) (b : b) : pair a b =
    $'!a, !b '

/// ### from_pair
inl from_pair forall a b. (pair : pair a b) : a * b =
    $'let (a, b) = !pair '
    $'a', $'b'

/// ## ref

/// ### ref
nominal ref t = $'`t ref'

/// ### new_ref
inl new_ref forall t. (x : t) : ref t =
    $'ref !x '

/// ### ref_value
inl ref_value forall t. (x : ref t) : t =
    $'!x.Value'

/// ### ref_set_value
inl ref_set_value forall t. (value : t) (ref : ref t) : ref t =
    $'!ref.Value <- !value '
    ref

/// ## target

/// ### target_runtime
union target_runtime =
    | Native
    | Wasm
    | Contract

/// ### target
union target =
    | Rust : target_runtime
    | Fsharp : target_runtime
    | TypeScript : target_runtime
    | Python : target_runtime

/// ### run_target
inl run_target forall t. (fn : target -> (() -> t)) : t =
    inl result = dyn true
    $'let mutable _!result : `t option = None '
    $'\n#if FABLE_COMPILER || WASM || CONTRACT'
    $'\n#if FABLE_COMPILER_RUST && \!WASM && \!CONTRACT'
    fn (Rust Native) () |> emit_unit
    $'#endif\n#if FABLE_COMPILER_RUST && WASM'
    fn (Rust Wasm) () |> emit_unit
    $'#endif\n#if FABLE_COMPILER_RUST && CONTRACT'
    fn (Rust Contract) () |> emit_unit
    $'#endif\n#if FABLE_COMPILER_TYPESCRIPT'
    fn (TypeScript Native) () |> emit_unit
    $'#endif\n#if FABLE_COMPILER_PYTHON'
    fn (Python Native) () |> emit_unit
    $'#endif\n#else'
    fn (Fsharp Native) () |> emit_unit
    $'#endif'
    $'|> fun x -> _!result <- Some x'
    $'match _!result with Some x -> x | None -> failwith "base.run_target / _!result=None"'

/// ## convert

/// ### convert
inl convert forall t u. (x : t) : u =
    $'!x |> `u '

/// ### unbox
inl unbox forall t u. (x : t) : u =
    $'!x |> unbox<`u>'

/// ### u8
inl u8 forall t. (x : t) : u8 =
    x |> $'uint8'

/// ### u16
inl u16 forall t. (x : t) : u16 =
    x |> $'uint16'

/// ### u64
inl u64 forall t. (x : t) : u64 =
    x |> $'uint64'

/// ### i32
inl i32 forall t. (x : t) : i32 =
    x |> $'int32'

/// ### i64
inl i64 forall t. (x : t) : i64 =
    x |> $'int64'

/// ### f32
inl f32 forall t. (x : t) : f32 =
    x |> $'float32'

/// ### f64
inl f64 forall t. (x : t) : f64 =
    x |> $'float'

/// ### unativeint
nominal unativeint = $'unativeint'

/// ### convert_i32
inl convert_i32 forall t. (x : t) : i32 =
    x |> $'System.Convert.ToInt32'

/// ### convert_i32_base
inl convert_i32_base forall t. (base : i32) (x : t) : i32 =
    $'System.Convert.ToInt32 (!x, !base)'

/// ## error

/// ### exn
nominal exn = $'exn'

/// ### try
inl try forall t. (fn : () -> t) (ex_fn : exn -> option t) : option t =
    inl none = None : option t
    inl some (s : t) = Some s
    $'try !fn () |> !some with ex -> !ex_fn ex '

/// ### try_unit
inl try_unit forall t. (fn : () -> ()) (ex_fn : exn -> ()) : t =
    $'try'
    fn ()
    |> ignore
    $'with ex ->'
    ex_fn $'ex'
    |> ignore
    $'(*'
    $'*)'

/// ### try_finally
inl try_finally forall t. (fn : () -> ()) (finally : () -> ()) : t =
    $'try'
    fn ()
    |> ignore
    $'finally'
    finally ()
    |> ignore
    $'(*'
    $'*)'

/// ## reflection

/// ### get_union_fields
inl get_union_fields forall union_type. () : list union_type =
    real
        real_core.union_to_record
            `union_type
            forall union_record_type. =>
                real_core.record_type_fold
                    fun acc key =>
                        forall value. =>
                            inl item = real_core.nominal_create `union_type (key, ())
                            (::) `union_type item acc
                    (Nil `union_type)
                    `union_record_type

/// ### get_union_fields_untag
inl get_union_fields_untag forall union_type. () : list union_type =
    real
        real_core.union_to_record
            `union_type
            forall union_record_type. =>
                inl result =
                    real_core.record_type_fold_back
                        fun _key =>
                            forall value. (acc, (i : i32)) =>
                                inl item : union_type =
                                    real_core.union_untag `union_type i
                                        (fun k => forall v. => real_core.nominal_create `union_type (k, ()))
                                        (fun _ => failwith `union_type "Invalid tag.")
                                (::) `union_type item acc, (+) `i32 i 1
                        `union_record_type
                        (Nil `union_type, 0i32)
                inl result = fst `(list union_type) `i32 result
                listm.rev `union_type result
