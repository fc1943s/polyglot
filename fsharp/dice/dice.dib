#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"}]}}

#!fsharp

open System

let private random = Random ()

let rollD6 () = random.Next (1, 7)

#!fsharp

let numDices log max =
    let rec numDices' n p =
        if log then printfn $"numDices / n: {n} / max: {max} / p: {p}"
        if p >= max
        then n
        else numDices' (n + 1) (p * 6)
    numDices' 0 1

#!fsharp

let rec rollAcc log rolls power acc coeff =
    match rolls with
    | _ when power < 0 ->
        if log then printfn $"rollAcc / power: {power} / acc: {acc}"
        Some (acc, rolls)
    | [] -> None
    | roll :: rest when roll > 1 ->
        let value = (roll - 1) * coeff
        if log then printfn $"rollAcc / power: {power} / acc: {acc} / roll: {roll} / value: {value}"
        rollAcc log rest (power - 1) (acc + value) (coeff / 6)
    | roll :: rest ->
        if log then printfn $"rollAcc / power: {power} / acc: {acc} / roll: {roll}"
        rollAcc log rest (power - 1) acc (coeff / 6)

let fixedRoll log max rolls =
    let rec rollMax power =
        match rollAcc log rolls power 0 (pown 6 power) with
        | Some (result, _) when result >= 1 && result <= max -> Some result
        | _ -> None

    rollMax (List.length rolls - 1)

let progressiveRoll log max =
    let rec rollMax power =
        let coeff = pown 6 power
        let rec loop rolls size =
            if size < power + 1
            then loop (rollD6 () :: rolls) (size + 1)
            else
                match rollAcc log rolls power 0 coeff with
                | Some (result, _) when result >= 1 && result <= max -> result
                | _ -> loop (rollD6 () :: rolls) (size + 1)
        loop [] 0
    rollMax ((numDices log max) - 1)

#!fsharp

//// ignore

progressiveRoll true 2000

#!fsharp

//// ignore

[1..100]
|> List.map (fun _ -> progressiveRoll false 10)
|> List.groupBy id
|> List.map (fun (k, v) -> k, v.Length)
|> List.sortBy fst

#!fsharp

let rollMax fn max n =
    [1..n]
    |> List.map (fun _ -> fn false max)
    |> List.groupBy id
    |> List.map (fun (_, v) -> v.Length)

#!fsharp

//// ignore

let max = 10
let n = 30
let even = (n / max) |> int

let rec rollN current =
    let roll = rollMax progressiveRoll max n
    if roll |> List.forall ((=) even)
    then current
    else rollN (current + 1)

rollN 0

#!fsharp

//// ignore

[1..100] |> List.map (fun _ -> rollN 0) |> List.map float |> List.average

#!fsharp

let max = 2000
let dices = numDices true max
dices

#!fsharp

fixedRoll true 2000 [1; 5; 4; 4; 5]

#!fsharp

fixedRoll true 2000 [2; 2; 6; 4; 5]

#!fsharp

fixedRoll true 2000 [4; 1; 1; 2; 3]
