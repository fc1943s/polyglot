#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"}]}}

#!fsharp

open System

let private random = Random ()

let rollD6 () = random.Next (1, 7)

#!fsharp

let numDices log max =
    let rec numDices' n p =
        if log then printfn $"numDices / n: {n} / max: {max} / p: {p}"
        if p >= max
        then n
        else numDices' (n + 1) (p * 6)
    numDices' 0 1

#!fsharp

let pow6 = 1 |> Seq.unfold (fun state -> Some (state, state * 6)) |> Seq.cache
pow6

#!fsharp

let rec rollAcc log rolls power acc =
    match rolls with
    | _ when power < 0 ->
        if log then printfn $"rollAcc / power: {power} / acc: {acc}"
        Some (acc, rolls)
    | [] -> None
    | roll :: rest when roll > 1 ->
        let coeff = pow6 |> Seq.item power
        let value = (roll - 1) * coeff
        if log then printfn $"rollAcc / power: {power} / acc: {acc} / roll: {roll} / value: {value}"
        rollAcc log rest (power - 1) (acc + value)
    | roll :: rest ->
        if log then printfn $"rollAcc / power: {power} / acc: {acc} / roll: {roll}"
        rollAcc log rest (power - 1) acc

let fixedRoll log max rolls =
    let rec rollMax power =
        match rollAcc log rolls power 0 with
        | Some (result, _) when result >= 1 && result <= max -> Some result
        | _ -> None

    rollMax (List.length rolls - 1)

let progressiveRoll log reroll max =
    let rec rollMax power =
        let rec loop rolls size =
            if size < power + 1
            then loop (rollD6 () :: rolls) (size + 1)
            else
                match rollAcc log rolls power 0 with
                | Some (result, _) when result >= 1 && result <= max -> result
                | _ when reroll -> loop (List.init power (fun _ -> rollD6 ())) power
                | _ -> loop (rollD6 () :: rolls) (size + 1)
        loop [] 0
    rollMax ((numDices log max) - 1)

#!fsharp

//// ignore

progressiveRoll true false 2000

#!fsharp

//// ignore

[1..100]
|> List.map (fun _ -> progressiveRoll false true 10)
|> List.groupBy id
|> List.map (fun (k, v) -> k, v.Length)
|> List.sortBy fst

#!fsharp

let rollMax fn max n =
    [1..n]
    |> List.map (fun _ -> fn max)
    |> List.groupBy id
    |> List.map (fun (_, v) -> v.Length)

#!fsharp

//// ignore

let max = 10
let n = 30
let even = (n / max) |> int

let rec rollN current =
    let roll = rollMax (progressiveRoll false true) max n
    if roll |> List.forall ((=) even)
    then current
    else rollN (current + 1)

rollN 0

#!fsharp

//// ignore

[1..100]
|> List.map (fun i ->
    let roll = rollN 0
    printfn $"i: {i} / roll: {roll}"
    roll
)
|> List.map float
|> List.average

#!fsharp

let max = 2000
let dices = numDices true max
dices

#!fsharp

fixedRoll true 2000 [1; 5; 4; 4; 5]

#!fsharp

fixedRoll true 2000 [2; 2; 6; 4; 5]

#!fsharp

fixedRoll true 2000 [4; 1; 1; 2; 3]
