#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"}]}}

#!fsharp

open System

let private random = Random ()

let rollD6 () = random.Next (1, 7)

#!fsharp

let rec numDices log max =
    let rec numDices' n =
        if log then printfn $"numDices / n: {n} / max: {max} / pown: {pown 6 n}"
        if pown 6 n >= max
        then n
        else numDices' (n + 1)
    numDices' 0

#!fsharp

let rec rollAcc log rolls power acc =
    match rolls, power with
    | _, power when power < 0 ->
        if log then printfn $"rollAcc / power: {power} / acc: {acc}"
        Some (acc, rolls)
    | [], _ -> None
    | roll :: rest, _ ->
        let value = (roll - 1) * (pown 6 power)
        if log then printfn $"rollAcc / power: {power} / acc: {acc} / roll: {roll} / value: {value}"
        rollAcc log rest (power - 1) (acc + value)

let fixedRoll log max rolls =
    let rec rollMax power =
        match rollAcc log rolls power 0 with
        | Some (result, _) when result >= 1 && result <= max -> Some result
        | _ -> None

    rollMax (List.length rolls - 1)

let progressiveRoll log max =
    let rec rollMax power =
        let rolls = List.init (power + 1) (fun _ -> rollD6 ())
        match rollAcc log rolls power 0 with
        | Some (result, _) when result >= 1 && result <= max -> result
        | _ -> rollMax power

    rollMax ((numDices log max) - 1)

#!fsharp

//// ignore

progressiveRoll true 2000

#!fsharp

//// ignore

[1..100]
|> List.map (fun _ -> progressiveRoll false 10)
|> List.groupBy id
|> List.map (fun (k, v) -> k, v.Length)
|> List.sortBy fst

#!fsharp

let rollMax fn max n =
    [1..n]
    |> List.map (fun _ -> fn false max)
    |> List.groupBy id
    |> List.map (fun (_, v) -> v.Length)

#!fsharp

//// ignore

let max = 10
let n = 30
let even = (n / max) |> int

let rec rollN current =
    let roll = rollMax progressiveRoll max n
    if roll |> List.forall ((=) even)
    then current
    else rollN (current + 1)

rollN 0

#!fsharp

//// ignore

[1..100] |> List.map (fun _ -> rollN 0) |> List.map float |> List.average

#!fsharp

let max = 2000
let dices = numDices true max
dices

#!fsharp

fixedRoll true 2000 [1; 5; 4; 4; 5]

#!fsharp

fixedRoll true 2000 [2; 2; 6; 4; 5]

#!fsharp

fixedRoll true 2000 [4; 1; 1; 2; 3]
