#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"},{"aliases":[],"name":"fsharp"}]}}

#!fsharp

#r "nuget:Expecto"

#!markdown

## ParserLibrary

#!fsharp

open System

#!markdown

### TextInput

#!fsharp

type Position =
    {
        line : int
        column : int
    }

#!fsharp

let initialPos = { line = 0; column = 0 }

#!fsharp

let incrCol (pos : Position) =
    { pos with column = pos.column + 1 }

#!fsharp

let incrLine pos =
    { line = pos.line + 1; column = 0 }

#!fsharp

type InputState =
    {
        lines : string[]
        position : Position
    }

#!fsharp

let currentLine inputState =
    let linePos = inputState.position.line
    if linePos < inputState.lines.Length then
        inputState.lines.[linePos]
    else
        "end of file"

#!fsharp

let fromStr str =
    if String.IsNullOrEmpty str then
        { lines = [||]; position = initialPos }
    else
        let separators = [| "\r\n"; "\n" |]
        let lines = str.Split (separators, StringSplitOptions.None)
        { lines = lines; position = initialPos }

#!fsharp

/// Get the next character from the input, if any
/// else return None. Also return the updated InputState
/// Signature: InputState -> InputState * char option
let nextChar input =
    let linePos = input.position.line
    let colPos = input.position.column
    // three cases
    // 1) if line >= maxLine ->
    //       return EOF
    // 2) if col less than line length ->
    //       return char at colPos, increment colPos
    // 3) if col at line length ->
    //       return NewLine, increment linePos

    if linePos >= input.lines.Length then
        input, None
    else
        let currentLine = currentLine input
        if colPos < currentLine.Length then
            let char = currentLine.[colPos]
            let newPos = incrCol input.position
            let newState = { input with position = newPos }
            newState, Some char
        else
            // end of line, so return LF and move to next line
            let char = '\n'
            let newPos = incrLine input.position
            let newState = { input with position = newPos }
            newState, Some char

#!markdown

### Parser

#!fsharp

// Aliases for input, etc
type Input = InputState // type alias
type ParserLabel = string
type ParserError = string

/// Stores information about the parser position for error messages
type ParserPosition =
    {
        currentLine : string
        line : int
        column : int
    }

// Result type
type ParseResult<'a> =
    | Success of 'a
    | Failure of ParserLabel * ParserError * ParserPosition

/// A Parser structure has a parsing function & label
type Parser<'a> =
    {
        parseFn : Input -> ParseResult<'a * Input>
        label : ParserLabel
    }

#!fsharp

/// Run the parser on a InputState
let runOnInput parser input =
    // call inner function with input
    parser.parseFn input

#!fsharp

/// Run the parser on a string
let run parser inputStr =
    // call inner function with input
    runOnInput parser (fromStr inputStr)

#!fsharp

// =============================================
// Error messages
// =============================================
let parserPositionFromInputState (inputState : Input) =
    {
        currentLine = currentLine inputState
        line = inputState.position.line
        column = inputState.position.column
    }

#!fsharp

let printResult result =
    match result with
    | Success (value, input) ->
        printfn $"%A{value}"
    | Failure (label, error, parserPos) ->
        let errorLine = parserPos.currentLine
        let colPos = parserPos.column
        let linePos = parserPos.line
        let failureCaret = $"{' '.ToString().PadLeft colPos}^{error}"
        printfn $"Line:%i{linePos} Col:%i{colPos} Error parsing %s{label}\n%s{errorLine}\n%s{failureCaret}"

#!fsharp

// =============================================
// Label related
// =============================================

#!fsharp

let getLabel parser =
    parser.label

#!fsharp

/// update the label in the parser
let setLabel parser newLabel =
    // change the inner function to use the new label
    let newInnerFn input =
        let result = parser.parseFn input
        match result with
        | Success s ->
            // if Success, do nothing
            Success s
        | Failure (oldLabel, err, pos) ->
            // if Failure, return new label
            Failure (newLabel, err, pos)
    // return the Parser
    { parseFn = newInnerFn; label = newLabel }

#!fsharp

/// infix version of setLabel
let (<?>) = setLabel

#!fsharp

// =============================================
// Standard combinators
// =============================================

/// Match an input token if the predicate is satisfied
let satisfy predicate label =
    let innerFn input =
        let remainingInput, charOpt = nextChar input
        match charOpt with
        | None ->
            let err = "No more input"
            let pos = parserPositionFromInputState input
            Failure (label, err, pos)
        | Some first ->
            if predicate first then
                Success (first, remainingInput)
            else
                let err = $"Unexpected '%c{first}'"
                let pos = parserPositionFromInputState input
                Failure (label, err, pos)
    // return the parser
    { parseFn = innerFn; label = label }

#!fsharp

/// "bindP" takes a parser-producing function f, and a parser p
/// and passes the output of p into f, to create a new parser
let bindP f p =
    let label = "unknown"
    let innerFn input =
        let result1 = runOnInput p input
        match result1 with
        | Failure (label, err, pos) ->
            // return error from parser1
            Failure (label, err, pos)
        | Success (value1, remainingInput) ->
            // apply f to get a new parser
            let p2 = f value1
            // run parser with remaining input
            runOnInput p2 remainingInput
    { parseFn = innerFn; label = label }

#!fsharp

/// Infix version of bindP
let (>>=) p f = bindP f p

#!fsharp

/// Lift a value to a Parser
let returnP x =
    let label = $"%A{x}"
    let innerFn input =
        // ignore the input and return x
        Success (x, input)
    // return the inner function
    { parseFn = innerFn; label = label }

#!fsharp

/// apply a function to the value inside a parser
let mapP f =
    bindP (f >> returnP)

#!fsharp

/// infix version of mapP
let (<!>) = mapP

#!fsharp

/// "piping" version of mapP
let (|>>) x f = mapP f x

#!fsharp

/// apply a wrapped function to a wrapped value
let applyP fP xP =
    fP >>= 
        fun f ->
            xP >>= 
                fun x ->
                    returnP (f x)

#!fsharp

/// infix version of apply
let (<*>) = applyP

#!fsharp

/// lift a two parameter function to Parser World
let lift2 f xP yP =
    returnP f <*> xP <*> yP

#!fsharp

/// Combine two parsers as "A andThen B"
let andThen p1 p2 =
    p1 >>= 
        fun p1Result ->
            p2 >>= 
                fun p2Result ->
                    returnP (p1Result, p2Result)
    <?> $"{getLabel p1} andThen {getLabel p2}"

#!fsharp

/// Infix version of andThen
let (.>>.) = andThen

#!fsharp

/// Combine two parsers as "A orElse B"
let orElse p1 p2 =
    let label = $"{getLabel p1} orElse {getLabel p2}"
    let innerFn input =
        // run parser1 with the input
        let result1 = runOnInput p1 input

        // test the result for Failure/Success
        match result1 with
        | Success result ->
            // if success, return the original result
            result1

        | Failure _ ->
            // if failed, run parser2 with the input
            let result2 = runOnInput p2 input

            // return parser2's result
            result2

    // return the inner function
    { parseFn = innerFn; label = label }

#!fsharp

/// Infix version of orElse
let (<|>) = orElse

#!fsharp

/// Choose any of a list of parsers
let choice listOfParsers =
    listOfParsers |> List.reduce (<|>)

let rec sequence parserList =
    // define the "cons" function, which is a two parameter function
    let cons head tail = head :: tail

    // lift it to Parser World
    let consP = lift2 cons

    // process the list of parsers recursively
    match parserList with
    | [] -> returnP []
    | head :: tail -> consP head (sequence tail)

#!fsharp

/// (helper) match zero or more occurences of the specified parser
let rec parseZeroOrMore parser input =
    // run parser with the input
    let firstResult = runOnInput parser input
    // test the result for Failure/Success
    match firstResult with
    | Failure (_, _, _) ->
        // if parse fails, return empty list
        [], input
    | Success (firstValue, inputAfterFirstParse) ->
        // if parse succeeds, call recursively
        // to get the subsequent values
        let (subsequentValues, remainingInput) =
            parseZeroOrMore parser inputAfterFirstParse
        let values = firstValue :: subsequentValues
        values, remainingInput

#!fsharp

/// matches zero or more occurences of the specified parser
let many parser =
    let label = $"many {getLabel parser}"
    let innerFn input =
        // parse the input -- wrap in Success as it always succeeds
        Success (parseZeroOrMore parser input)
    { parseFn = innerFn; label = label }

#!fsharp

/// matches one or more occurences of the specified parser
let many1 p =
    p >>=
        fun head ->
            many p >>=
                fun tail ->
                    returnP (head :: tail)
    <?> $"many1 {getLabel p}"

#!fsharp

/// Parses an optional occurrence of p and returns an option value.
let opt p =
    let some = p |>> Some
    let none = returnP None
    (some <|> none)
    <?> $"opt {getLabel p}"

#!fsharp

/// Keep only the result of the left side parser
let (.>>) p1 p2 =
    // create a pair
    p1 .>>. p2
    // then only keep the first value
    |> mapP fst

#!fsharp

/// Keep only the result of the right side parser
let (>>.) p1 p2 =
    // create a pair
    p1 .>>. p2
    // then only keep the second value
    |> mapP snd

#!fsharp

/// Keep only the result of the middle parser
let between p1 p2 p3 =
    p1 >>. p2 .>> p3

#!fsharp

/// Parses one or more occurrences of p separated by sep
let sepBy1 p sep =
    let sepThenP = sep >>. p
    p .>>. many sepThenP
    |>> fun (p, pList) -> p :: pList

#!fsharp

/// Parses zero or more occurrences of p separated by sep
let sepBy p sep =
    sepBy1 p sep <|> returnP []

#!fsharp

// =============================================
// Standard parsers
// =============================================

// ------------------------------
// char and string parsing
// ------------------------------

#!fsharp

/// parse a char
let pchar charToMatch =
    // label is just the character
    let label = $"%c{charToMatch}"

    let predicate ch = ch = charToMatch
    satisfy predicate label

#!fsharp

/// Choose any of a list of characters
let anyOf listOfChars =
    let label = $"anyOf %A{listOfChars}"
    listOfChars
    |> List.map pchar // convert into parsers
    |> choice
    <?> label

#!fsharp

/// Convert a list of chars to a string
let charListToStr charList =
    charList |> List.toArray |> String

#!fsharp

/// Parses a sequence of zero or more chars with the char parser cp.
/// It returns the parsed chars as a string.
let manyChars cp =
    many cp
    |>> charListToStr

#!fsharp

/// Parses a sequence of one or more chars with the char parser cp.
/// It returns the parsed chars as a string.
let manyChars1 cp =
    many1 cp
    |>> charListToStr

#!fsharp

/// parse a specific string
let pstring str =
    // label is just the string
    let label = str

    str
    // convert to list of char
    |> List.ofSeq
    // map each char to a pchar
    |> List.map pchar
    // convert to Parser<char list>
    |> sequence
    // convert Parser<char list> to Parser<string>
    |> mapP charListToStr
    <?> label

#!fsharp

// ------------------------------
// whitespace parsing
// ------------------------------

#!fsharp

/// parse a whitespace char
let whitespaceChar =
    let predicate = Char.IsWhiteSpace
    let label = "whitespace"
    satisfy predicate label

#!fsharp

/// parse zero or more whitespace char
let spaces = many whitespaceChar

#!fsharp

/// parse one or more whitespace char
let spaces1 = many1 whitespaceChar

#!fsharp

// ------------------------------
// number parsing
// ------------------------------

#!fsharp

/// parse a digit
let digitChar =
    let predicate = Char.IsDigit
    let label = "digit"
    satisfy predicate label

#!fsharp

// parse an integer
let pint =
    // helper
    let resultToInt (sign, digits) =
        let i = int digits  // ignore int overflow for now
        match sign with
        | Some ch -> -i  // negate the int
        | None -> i

    // define parser for one or more digits
    let digits = manyChars1 digitChar

    // an "int" is optional sign + one or more digits
    opt (pchar '-') .>>. digits
    |> mapP resultToInt
    <?> "integer"

#!fsharp

let pfloat =
    // helper
    let resultToFloat (((sign, digits1), point), digits2) =
        let fl = float $"{digits1}.{digits2}"
        match sign with
        | Some ch -> -fl  // negate the float
        | None -> fl

    // define parser for one or more digits
    let digits = manyChars1 digitChar

    // a float is sign, digits, point, digits (ignore exponents for now)
    opt (pchar '-') .>>. digits .>>. pchar '.' .>>. digits
    |> mapP resultToFloat
    <?> "float"

#!markdown

## JsonParser

#!fsharp

(*
// --------------------------------
JSON spec from http://www.json.org/
// --------------------------------

The JSON spec is available at [json.org](http://www.json.org/). I'll paraphase it here:

* A `value` can be a `string` or a `number` or a `bool` or `null` or an `object` or an `array`.
  * These structures can be nested.
* A `string` is a sequence of zero or more Unicode characters, wrapped in double quotes, using backslash escapes.
* A `number` is very much like a C or Java number, except that the octal and hexadecimal formats are not used.
* A `boolean` is the literal `true` or `false`
* A `null` is the literal `null`
* An `object` is an unordered set of name/value pairs.
  * An object begins with { (left brace) and ends with } (right brace).
  * Each name is followed by : (colon) and the name/value pairs are separated by , (comma).
* An `array` is an ordered collection of values.
  * An array begins with [ (left bracket) and ends with ] (right bracket).
  * Values are separated by , (comma).
* Whitespace can be inserted between any pair of tokens.

*)

#!fsharp

type JValue =
    | JString of string
    | JNumber of float
    | JBool   of bool
    | JNull
    | JObject of Map<string, JValue>
    | JArray  of JValue list

#!fsharp

// ======================================
// Forward reference
// ======================================

#!fsharp

/// Create a forward reference
let createParserForwardedToRef<'a> () =

    let dummyParser : Parser<'a> =
        let innerFn _ = failwith "unfixed forwarded parser"
        { parseFn = innerFn; label = "unknown" }

    // ref to placeholder Parser
    let mutable parserRef = dummyParser

    // wrapper Parser
    let innerFn input =
        // forward input to the placeholder
        // (Note: "!" is the deferencing operator)
        runOnInput parserRef input
    let wrapperParser = { parseFn = innerFn; label = "unknown" }

    wrapperParser, (fun v -> parserRef <- v)

#!fsharp

let jValue, jValueRef = createParserForwardedToRef<JValue> ()

#!fsharp

// applies the parser p, ignores the result, and returns x.
let (>>%) p x =
    p |>> fun _ -> x

#!fsharp

let jNull =
    pstring "null"
    >>% JNull
    <?> "null"

#!fsharp

let jBool =
    let jtrue =
        pstring "true"
        >>% JBool true
    let jfalse =
        pstring "false"
        >>% JBool false

    jtrue <|> jfalse
    <?> "bool"

#!fsharp

let jUnescapedChar =
    satisfy (fun ch -> ch <> '\\' && ch <> '\"') "char"

#!fsharp

let jEscapedChar =
    [
    // (stringToMatch, resultChar)
    ("\\\"",'\"')      // quote
    ("\\\\",'\\')      // reverse solidus
    ("\\/",'/')        // solidus
    ("\\b",'\b')       // backspace
    ("\\f",'\f')       // formfeed
    ("\\n",'\n')       // newline
    ("\\r",'\r')       // cr
    ("\\t",'\t')       // tab
    ]
    // convert each pair into a parser
    |> List.map (fun (toMatch, result) ->
        pstring toMatch >>% result
    )
    // and combine them into one
    |> choice
    <?> "escaped char" // set label

#!fsharp

let jUnicodeChar =

    // set up the "primitive" parsers
    let backslash = pchar '\\'
    let uChar = pchar 'u'
    let hexdigit = anyOf (['0'..'9'] @ ['A'..'F'] @ ['a'..'f'])
    let fourHexDigits = hexdigit .>>. hexdigit .>>. hexdigit .>>. hexdigit

    // convert the parser output (nested tuples)
    // to a char
    let convertToChar (((h1, h2), h3), h4) =
        let str = $"%c{h1}%c{h2}%c{h3}%c{h4}"
        Int32.Parse (str, Globalization.NumberStyles.HexNumber) |> char

    // set up the main parser
    backslash  >>. uChar >>. fourHexDigits
    |>> convertToChar

#!fsharp

let quotedString =
    let quote = pchar '\"' <?> "quote"
    let jchar = jUnescapedChar <|> jEscapedChar <|> jUnicodeChar

    // set up the main parser
    quote >>. manyChars jchar .>> quote

#!fsharp

let jString =
    // wrap the string in a JString
    quotedString
    |>> JString           // convert to JString
    <?> "quoted string"   // add label

#!fsharp

let jNumber =

    // set up the "primitive" parsers
    let optSign = opt (pchar '-')

    let zero = pstring "0"

    let digitOneNine =
        satisfy (fun ch -> Char.IsDigit ch && ch <> '0') "1-9"

    let digit =
        satisfy (fun ch -> Char.IsDigit ch) "digit"

    let point = pchar '.'

    let e = pchar 'e' <|> pchar 'E'

    let optPlusMinus = opt (pchar '-' <|> pchar '+')

    let nonZeroInt =
        digitOneNine .>>. manyChars digit
        |>> fun (first, rest) -> string first + rest

    let intPart = zero <|> nonZeroInt

    let fractionPart = point >>. manyChars1 digit

    let exponentPart = e >>. optPlusMinus .>>. manyChars1 digit

    // utility function to convert an optional value to a string, or "" if missing
    let (|>?) opt f =
        match opt with
        | None -> ""
        | Some x -> f x

    let convertToJNumber (((optSign, intPart), fractionPart), expPart) =
        // convert to strings and let .NET parse them! - crude but ok for now.

        let signStr =
            optSign
            |>? string   // e.g. "-"

        let fractionPartStr =
            fractionPart
            |>? (fun digits -> "." + digits)  // e.g. ".456"

        let expPartStr =
            expPart
            |>? fun (optSign, digits) ->
                let sign = optSign |>? string
                "e" + sign + digits          // e.g. "e-12"

        // add the parts together and convert to a float, then wrap in a JNumber
        (signStr + intPart + fractionPartStr + expPartStr)
        |> float
        |> JNumber

    // set up the main parser
    optSign .>>. intPart .>>. opt fractionPart .>>. opt exponentPart
    |>> convertToJNumber
    <?> "number"   // add label

#!fsharp

let jArray =

    // set up the "primitive" parsers
    let left = pchar '[' .>> spaces
    let right = pchar ']' .>> spaces
    let comma = pchar ',' .>> spaces
    let value = jValue .>> spaces

    // set up the list parser
    let values = sepBy value comma

    // set up the main parser
    between left values right
    |>> JArray
    <?> "array"

#!fsharp

let jObject =

    // set up the "primitive" parsers
    let left = spaces >>. pchar '{' .>> spaces
    let right = pchar '}' .>> spaces
    let colon = pchar ':' .>> spaces
    let comma = pchar ',' .>> spaces
    let key = quotedString .>> spaces
    let value = jValue .>> spaces

    // set up the list parser
    let keyValue = (key .>> colon) .>>. value
    let keyValues = sepBy keyValue comma

    // set up the main parser
    between left keyValues right
    |>> Map.ofList  // convert the list of keyValues into a Map
    |>> JObject     // wrap in JObject
    <?> "object"    // add label

#!fsharp

jValueRef <|
    choice
        [
            jNull
            jBool
            jNumber
            jString
            jArray
            jObject
        ]

#!markdown

## tests

#!fsharp

let expect (expected : ParseResult<'a>) (actual : ParseResult<'a * Input>) =
    match actual, expected with
    | Success (_actual, _), Success _expected ->
        printResult actual
        "" |> Expecto.Expect.equal _actual _expected
    | Failure (l1, e1, p1), Failure (l2, e2, p2) when l1 = l2 && e1 = e2 && p1 = p2 -> 
        printResult actual
    | _ ->
        printfn $"Actual: {actual}"
        printfn $"Expected: {expected}"
        failwith "Parse failed"
    actual

#!fsharp

run jValue "null"
|> expect (Success JNull)

#!fsharp

run jNull "nulp"
|> expect (
    Failure (
        "null",
        "Unexpected 'p'",
        { currentLine = "nulp"; line = 0; column = 3 }
    )
)

#!fsharp

run jBool "true"
|> expect (Success (JBool true))

#!fsharp

run jBool "false"
|> expect (Success (JBool false))

#!fsharp

run jBool "truX"
|> expect (
    Failure (
        "bool",
        "Unexpected 't'",
        { currentLine = "truX"; line = 0; column = 0 }
    )
)

#!fsharp

run jUnescapedChar "a"
|> expect (Success 'a')

#!fsharp

run jUnescapedChar "\\"
|> expect (
    Failure (
        "char",
        "Unexpected '\\'",
        { currentLine = "\\"; line = 0; column = 0 }
    )
)

#!fsharp

run jEscapedChar "\\\\"
|> expect (Success '\\')

#!fsharp

run jEscapedChar "\\t"
|> expect (Success '\t')

#!fsharp

run jEscapedChar @"\\"
|> expect (Success '\\')

#!fsharp

run jEscapedChar @"\n"
|> expect (Success '\n')

#!fsharp

run jEscapedChar "a"
|> expect (
    Failure (
        "escaped char",
        "Unexpected 'a'",
        { currentLine = "a"; line = 0; column = 0 }
    )
)

#!fsharp

run jUnicodeChar "\\u263A"
|> expect (Success '☺')

#!fsharp

run jString "\"\""
|> expect (Success (JString ""))

#!fsharp

run jString "\"a\""
|> expect (Success (JString "a"))

#!fsharp

run jString "\"ab\""
|> expect (Success (JString "ab"))

#!fsharp

run jString "\"ab\\tde\""
|> expect (Success (JString "ab\tde"))

#!fsharp

run jString "\"ab\\u263Ade\""
|> expect (Success (JString "ab☺de"))

#!fsharp

run jNumber "123"
|> expect (Success (JNumber 123.0))

#!fsharp

run jNumber "-123"
|> expect (Success (JNumber -123.0))

#!fsharp

run jNumber "123.4"
|> expect (Success (JNumber 123.4))

#!fsharp

run jNumber "-123."
|> expect (Success (JNumber -123.0))

#!fsharp

run jNumber "00.1"
|> expect (Success (JNumber 0.0))

#!fsharp

let jNumber_ = jNumber .>> spaces1

#!fsharp

run jNumber_ "123"
|> expect (Success (JNumber 123.0))

#!fsharp

run jNumber_ "-123"
|> expect (Success (JNumber -123.0))

#!fsharp

run jNumber_ "-123."
|> expect (
    Failure (
        "number andThen many1 whitespace",
        "Unexpected '.'",
        { currentLine = "-123."; line = 0; column = 4 }
    )
)

#!fsharp

run jNumber_ "123.4"
|> expect (Success (JNumber 123.4))

#!fsharp

run jNumber_ "00.4"
|> expect (
    Failure (
        "number andThen many1 whitespace",
        "Unexpected '0'",
        { currentLine = "00.4"; line = 0; column = 1 }
    )
)

#!fsharp

run jNumber_ "123e4"
|> expect (Success (JNumber 1230000.0))

#!fsharp

run jNumber_ "123.4e5"
|> expect (Success (JNumber 12340000.0))

#!fsharp

run jNumber_ "123.4e-5"
|> expect (Success (JNumber 0.001234))

#!fsharp

run jArray "[ 1, 2 ]"
|> expect (Success (JArray [JNumber 1.0; JNumber 2.0]))

#!fsharp

run jArray "[ 1, 2, ]"
|> expect (
    Failure (
        "array",
        "Unexpected ','",
        { currentLine = "[ 1, 2, ]"; line = 0; column = 6 }
    )
)

#!fsharp

run jObject """{ "a":1, "b"  :  2 }"""
|> expect (
    Success (
        JObject (
            Map.ofList [
                "a", JNumber 1.0
                "b", JNumber 2.0
            ]
        )
    )
)

#!fsharp

run jObject """{ "a":1, "b"  :  2, }"""
|> expect (
    Failure (
        "object",
        "Unexpected ','",
        { currentLine = "{ \"a\":1, \"b\"  :  2, }"; line = 0; column = 18 }
    )
)

#!fsharp

let example1 = """{
    "name" : "Scott",
    "isMale" : true,
    "bday" : {"year":2001, "month":12, "day":25 },
    "favouriteColors" : ["blue", "green"],
    "emptyArray" : [],
    "emptyObject" : {}
}"""
run jValue example1
|> expect (
    Success (
        JObject (
            Map.ofList [
                "name", JString "Scott"
                "isMale", JBool true
                "bday", JObject (
                    Map.ofList [
                        "year", JNumber 2001.0
                        "month", JNumber 12.0
                        "day", JNumber 25.0
                    ]
                )
                "favouriteColors", JArray [JString "blue"; JString "green"]
                "emptyArray", JArray []
                "emptyObject", JObject Map.empty
            ]
        )
    )
)

#!fsharp

let example2= """{"widget": {
    "debug": "on",
    "window": {
        "title": "Sample Konfabulator Widget",
        "name": "main_window",
        "width": 500,
        "height": 500
    },
    "image": {
        "src": "Images/Sun.png",
        "name": "sun1",
        "hOffset": 250,
        "vOffset": 250,
        "alignment": "center"
    },
    "text": {
        "data": "Click Here",
        "size": 36,
        "style": "bold",
        "name": "text1",
        "hOffset": 250,
        "vOffset": 100,
        "alignment": "center",
        "onMouseUp": "sun1.opacity = (sun1.opacity / 100) * 90;"
    }
}}  """

run jValue example2
|> expect (
    Success (
        JObject (
            Map.ofList [
                "widget", JObject (
                    Map.ofList [
                        "debug", JString "on"
                        "window", JObject (
                            Map.ofList [
                                "title", JString "Sample Konfabulator Widget"
                                "name", JString "main_window"
                                "width", JNumber 500.0
                                "height", JNumber 500.0
                            ]
                        )
                        "image", JObject (
                            Map.ofList [
                                "src", JString "Images/Sun.png"
                                "name", JString "sun1"
                                "hOffset", JNumber 250.0
                                "vOffset", JNumber 250.0
                                "alignment", JString "center"
                            ]
                        )
                        "text", JObject (
                            Map.ofList [
                                "data", JString "Click Here"
                                "size", JNumber 36.0
                                "style", JString "bold"
                                "name", JString "text1"
                                "hOffset", JNumber 250.0
                                "vOffset", JNumber 100.0
                                "alignment", JString "center"
                                "onMouseUp", JString "sun1.opacity = (sun1.opacity / 100) * 90;"
                            ]
                        )
                    ]
                )
            ]
        )
    )
)

#!fsharp

let example3 = """{
  "string": "Hello, \"World\"!",
  "escapedString": "This string contains \\/\\\\\\b\\f\\n\\r\\t\\\"\\'",
  "number": 42,
  "scientificNumber": 3.14e-10,
  "boolean": true,
  "nullValue": null,
  "array": [1, 2, 3, 4, 5],
  "unicodeString1": "프리마",
  "unicodeString2": "\u0048\u0065\u006C\u006C\u006F, \u0022\u0057\u006F\u0072\u006C\u0064\u0022!",
  "specialCharacters": "!@#$%^&*()",
  "emptyArray": [],
  "emptyObject": {},
  "nestedArrays": [[1, 2, 3], [4, 5, 6]],
  "object": {
    "nestedString": "Nested Value",
    "nestedNumber": 3.14,
    "nestedBoolean": false,
    "nestedNull": null,
    "nestedArray": ["a", "b", "c"],
    "nestedObject": {
      "nestedProperty": "Nested Object Value"
    }
  },
  "nestedObjects": [
    {"name": "Alice", "age": 25},
    {"name": "Bob", "age": 30}
  ]
}"""
run jValue example3
|> expect (
    Success (
        JObject (
            Map.ofList [
                "string", JString @"Hello, ""World""!"
                "escapedString", JString @"This string contains \/\\\b\f\n\r\t\""\'"
                "number", JNumber 42.0
                "scientificNumber", JNumber 3.14e-10
                "boolean", JBool true
                "nullValue", JNull
                "array", JArray [
                    JNumber 1.0; JNumber 2.0; JNumber 3.0; JNumber 4.0; JNumber 5.0
                ]
                "unicodeString1", JString "프리마"
                "unicodeString2", JString @"Hello, ""World""!"
                "specialCharacters", JString "!@#$%^&*()"
                "emptyArray", JArray []
                "emptyObject", JObject Map.empty
                "nestedArrays", JArray [
                    JArray [JNumber 1.0; JNumber 2.0; JNumber 3.0]
                    JArray [JNumber 4.0; JNumber 5.0; JNumber 6.0]
                ]
                "object", JObject (
                    Map.ofList [
                        "nestedString", JString "Nested Value"
                        "nestedNumber", JNumber 3.14
                        "nestedBoolean", JBool false
                        "nestedNull", JNull
                        "nestedArray", JArray [JString "a"; JString "b"; JString "c"]
                        "nestedObject", JObject (
                            Map.ofList [
                                "nestedProperty", JString "Nested Object Value"
                            ]
                        )
                    ]
                )
                "nestedObjects", JArray [
                  JObject (Map.ofList ["name", JString "Alice"; "age", JNumber 25.0])
                  JObject (Map.ofList ["name", JString "Bob"; "age", JNumber 30.0])
                ]
            ]
        )
    )
)
