#!meta

{"kernelInfo":{"defaultKernelName":"fsharp","items":[]}}

#!markdown

## Physics (Polyglot)

#!fsharp

#!import ../nbs/Plotting.dib

#!markdown

## Testing

#!spiral

// // test

inl _almost_equal b a =
    assert (abs (b - a) < 0.00000001) $"$\"_almost_equal / actual: {!a} / expected: {!b}\""

inl _equal b a =
    assert (a = b) $"$\"_equal / actual: {!a} / expected: {!b}\""

inl _is_less_than b a =
    assert (b < a) $"$\"_is_less_than / actual: {!a} / expected: {!b}\""

inl _is_less_than_or_equal b a =
    assert (b <= a) $"$\"_is_less_than_or_equal / actual: {!a} / expected: {!b}\""

#!markdown

## Math

#!spiral

inl atan2 (y : f64) (x : f64) =
    $"System.Math.Atan2 (!y, !x)" : f64

inl cos (d : f64) =
    $"System.Math.Cos !d" : f64

inl e () =
    exp 1f64

inl log_base (new_base : f64) (a : f64) =
    $"System.Math.Log (!a, !new_base)" : f64

inl pi () =
    $"System.Math.PI" : f64

inl round forall t {float}. (x : t) : t =
    $"round !x"

inl sin (d : f64) =
    $"System.Math.Sin !d" : f64

inl square x =
    x ** 2

#!spiral

// // test

2 * 2 / 0.4f64 |> sqrt
|> _almost_equal 3.1622776601683795

#!spiral

// // test

2f64 / 3
|> _almost_equal 0.6666666666666666

#!spiral

// // test

2f64 |> log
|> _almost_equal 0.6931471805599453

#!spiral

// // test

pi ()
|> _almost_equal 3.141592653589793

#!spiral

// // test

pi () |> cos
|> _equal -1

#!spiral

// // test

pi ()
|> cos
|> fun n => n / 2
|> _almost_equal -0.5

#!spiral

// // test

pi () / 2 |> cos
|> _almost_equal 0.00000000000000006123233995736766

#!spiral

// // test

100 |> log_base 10
|> _equal 2

#!spiral

// // test

0 |> atan2 1
|> _equal 1.5707963267948966

#!spiral

// // test

5f64
|> sqrt
|> square
|> _almost_equal 5

#!spiral

// // test

e () |> square
|> _almost_equal 7.3890560989306495

#!markdown

## iterate

#!spiral

inl iterate f x0 num_steps =
    inl rec loop x n =
        if n = 0
        then x
        else loop (f x) (n - 1)
    loop x0 num_steps

inl iterate' f x0 num_steps =
    listm.init num_steps id
    |> listm.fold (fun x _ => f x) x0

#!spiral

// // test


10i32 |> iterate ((+) 1) 1i32
|> _equal 11

10i32 |> iterate' ((+) 1) 1i32
|> _equal 11

#!markdown

## list

#!spiral

inl rec list_item i list =
    list |> function
    | Cons (x, xs) =>
        if i <= 0
        then x
        else list_item (i - 1) xs

#!spiral

// // test

listm.init 10i32 id
|> list_item 9i32
|> _equal 9

#!spiral

inl list_sum list =
    list |> listm.fold (+) 0

#!spiral

// // test

listm.init 10i32 id
|> list_sum
|> _equal 45

#!markdown

## a

#!spiral

inl a_sum (a' : a _ _) =
    a' |> am.fold (+) 0

#!spiral

// // test

am.init 10i32 id
|> a_sum
|> _equal 45

#!markdown

## init_series

#!spiral

inl init_series start end inc =
    inl total = conv ((end - start) / inc) + 1
    am.init total (conv >> (*) inc >> (+) start) : a i32 _

inl init_series' start end inc =
    inl total : f64 = conv ((end - start) / inc) + 1
    listm.init total (conv >> (*) inc >> (+) start)

#!spiral

// // test

inl x : a _ f64 = init_series -3 3 0.01
inl y = x |> am.map square
"square", "x", x, "y", ;["square", y]

#!spiral

// // test

inl x = init_series -10 10 0.1
inl y_sin = x |> am.map sin
inl y_cos = x |> am.map cos
"sin cos", "x", x, "y", ;["sin", y_sin; "cos", y_cos]

#!spiral

// // test

inl y_pos y0 vy0 ay t =
    y0 + vy0 * t + ay * (t |> square) / 2

inl x : a _ f64 = init_series 0 5 0.01
inl y = x |> am.map (y_pos 0 20 -9.8)
"projectile motion", "time (s)", x, "", ;["height of projectile (m)", y]

#!markdown

## velocity_cf

#!spiral

type mass = f64
type time = f64
type position = f64
type velocity = f64
type force = f64

type velocity_cf = mass -> velocity -> list force -> (time -> velocity)

inl velocity_cf m v0 fs =
    inl f_net = fs |> list_sum
    inl a0 = f_net / m
    inl v t = v0 + a0 * t
    v

#!spiral

// // test

velocity_cf 0.1f64 0.6 [0.04; -0.08] 0
|> _equal 0.6

velocity_cf 0.1f64 0.6 [0.04; -0.08] 1
|> _equal 0.2

#!spiral

// // test

inl x = init_series 0 4 0.1
inl y = x |> am.map (velocity_cf 0.1f64 0.6 [0.04; -0.08])
"car on an air track", "time (s)", x, "", ;["velocity of car (m/s)", y]

#!markdown

## derivative

#!spiral

type derivative = (f64 -> f64) -> f64 -> f64

inl derivative dt : derivative =
    fun x t =>
        (x (t + dt / 2) - x (t - dt / 2)) / dt

#!spiral

// // test

derivative 1 (fun x => x ** 4 / 4) 1 - 1
|> _almost_equal 0.25

derivative 0.001 (fun x => x ** 4 / 4) 1 - 1
|> _almost_equal 0.0000002499998827953931

derivative 0.000001 (fun x => x ** 4 / 4) 1 - 1
|> _almost_equal 0.000000000001000088900582341

derivative 0.000000001 (fun x => x ** 4 / 4) 1 - 1
|> _almost_equal 0.00000008274037099909037

derivative 0.000000000001 (fun x => x ** 4 / 4) 1 - 1
|> _almost_equal 0.00008890058234101161

derivative 0.000000000000001 (fun x => x ** 4 / 4) 1 - 1
|> _almost_equal -0.0007992778373592246

derivative 0.000000000000000001 (fun x => x ** 4 / 4) 1 - 1
|> _almost_equal -1

#!markdown

## integration

#!spiral

type integration = (f64 -> f64) -> f64 -> f64 -> f64

inl integral dt : integration =
    fun f a b =>
        inl rec loop t y =
            if t < b
            then loop (t + dt) (y + f t * dt)
            else t, y
        loop (a + dt / 2) 0
        |> snd

#!spiral

// // test

integral 0.01 square 0 1
|> _almost_equal 0.33332500000000004

#!spiral

inl integral' dt : integration =
    fun f a b =>
        init_series' (a + dt / 2) (b - dt / 2) dt
        |> listm.map (f >> (*) dt)
        |> list_sum

#!spiral

// // test

integral' 0.1 square 0 1
|> _almost_equal (integral 0.1 square 0 1)

#!spiral

inl integral'' dt : integration =
    fun f a b =>
        init_series (a + dt / 2) (b - dt / 2) dt
        |> am.map (f >> (*) dt)
        |> a_sum

#!spiral

// // test

integral'' 0.01 square 0 1
|> _almost_equal 0.33332500000000004

#!markdown

## anti_derivative

#!spiral

inl anti_derivative dt v0 a t =
    v0 + integral' dt a 0 t

#!markdown

## velocity_ft

#!spiral

type velocity_ft = mass -> velocity -> list (time -> force) -> (time -> velocity)

inl velocity_ft dt : velocity_ft =
    fun m v0 fs =>
        inl f_net t = fs |> listm.map (fun f => f t) |> list_sum
        inl a t = f_net t / m
        anti_derivative dt v0 a

#!markdown

## position_ft

#!spiral

type position_ft = mass -> position -> velocity -> list (time -> force) -> (time -> position)

inl position_ft dt : position_ft =
    fun m x0 v0 fs =>
        velocity_ft dt m v0 fs
        |> anti_derivative dt x0

#!spiral

// // test

inl pedal_coast (t : time) : force =
    inl t_cycle = 20
    inl n_complete : i32 = t / t_cycle |> conv
    inl remainder = t - conv n_complete * t_cycle
    if remainder > 0 && remainder < 10
    then 10
    else 0

inl x = init_series -5 45 0.1
inl y = x |> am.map pedal_coast
"child pedaling then coasting", "time (s)", x, "", ;["force on bike (N)", y]

#!spiral

// // test

inl x = init_series -5 45 1
inl y = x |> am.map (position_ft 0.1f64 20 0 0 [pedal_coast])
"child pedaling then coasting", "time (s)", x, "", ;["position of bike (m)", y]

#!markdown

## velocity_fv

#!spiral

inl newton_second_v m fs v0 =
    fs |> listm.map (fun f => f v0) |> list_sum |> fun x => x / m

inl update_velocity dt m fs v0 =
    v0 + newton_second_v m fs v0 * dt

inl velocity_fv dt m v0 fs t =
    t / dt |> round |> abs
    |> iterate' (update_velocity dt m fs) v0

#!spiral

inl f_air drag rho area v =
    -drag * rho * area * abs v * v / 2

#!spiral

// // test

inl x = init_series 0 60 0.5
inl y = x |> am.map (velocity_fv 1 70 0f64 [fun _ => 100; f_air 2 1.225 0.6])
"bike velocity", "time (s)", x, "", ;["velocity of bike (m/s)", y]

#!markdown

## velocity_ftv

#!spiral

inl newton_second_tv m fs (t, v0) =
    inl f_net = fs |> listm.map (fun f => f (t, v0)) |> list_sum
    inl acc = f_net / m
    1, acc

inl update_tv dt m fs (t, v0) =
    inl dtdt, dvdt = newton_second_tv m fs (t, v0)
    t + dtdt * dt, v0 + dvdt * dt

inl velocity_ftv dt m tv0 fs t =
    t / dt |> round |> abs
    |> iterate' (update_tv dt m fs) tv0
    |> snd

#!spiral

// // test

inl x = init_series 0 100 0.1
inl y =
    x
    |> am.map (
        velocity_ftv 0.1 20 (0, 0) [fun (t, _) => pedal_coast t; fun (_, v) => f_air 2 1.225 0.5 v]
    )
"pedaling and coasting with air", "time (s)", x, "", ;["velocity of bike (m/s)", y]

#!spiral

// // test

type state_1d = time * position * velocity

inl newton_second_1d m fs (t, x0, v0) : state_1d =
    inl f_net = fs |> listm.map (fun f => f (t, x0, v0)) |> list_sum
    inl acc = f_net / m
    1f64, v0, acc

inl euler_1d dt deriv (t0, x0, v0) =
    inl _, _, dvdt = deriv (t0, x0, v0)
    inl t1 = t0 + dt
    inl x1 = x0 + v0 * dt
    inl v1 = v0 + dvdt * dt
    t1, x1, v1

inl update_txv dt m fs =
    newton_second_1d m fs |> euler_1d dt

inl states_txv dt m txv0 fs =
    iterate' (update_txv dt m fs) txv0

inl velocity_1d sts t =
    inl t0, _, _ = sts 0
    inl t1, _, _ = sts 1
    inl dt = t1 - t0
    inl num_steps = t / dt |> round |> abs
    inl _, _, v0 = sts num_steps
    v0

inl velocity_ftxv dt m txv0 fs =
    states_txv dt m txv0 fs |> velocity_1d

inl position_1d sts t =
    inl t0, _, _ = sts 0
    inl t1, _, _ = sts 1
    inl dt = t1 - t0
    inl num_steps = t / dt |> round |> abs
    inl _, x0, _ = sts num_steps
    x0

inl position_ftxv dt m txv0 fs =
    states_txv dt m txv0 fs |> position_1d

inl spring_force k (_, x0, _) =
    -k * x0

#!spiral

// // test

inl damped_ho_forces () =
    [
        spring_force 0.8
        fun _, _, v0 => f_air 2 1.225 (pi () * square 0.02) v0
        fun _ => -0.0027 * 9.80665
    ]
    
inl damped_ho_states () =
    states_txv 0.001 0.0027 (0.0, 0.1, 0.0) (damped_ho_forces ())
    
inl pingpong_position t =
    position_ftxv 0.001 0.0027 (0, 0.1, 0) (damped_ho_forces ()) t

inl x : a _ f64 = init_series 0 3 0.01
inl y = x |> am.map pingpong_position
"ping pong ball on a slinky", "time (s)", x, "", ;["position (m)", y]

#!spiral

// // test

inl pingpong_velocity t =
    velocity_ftxv 0.001 0.0027 (0, 0.1, 0) (damped_ho_forces ()) t

inl x = init_series 0 3 0.01
inl y = x |> am.map pingpong_velocity
"ping pong ball on a slinky", "time (s)", x, "", ;["velocity (m/s)", y]

#!markdown

## vec

#!spiral

type vec =
    {
        x : f64
        y : f64
        z : f64
    }

inl vec x y z : vec =
    { x y z }

#!spiral

// // test

vec 1 2 3 .z
|> _equal 3

#!markdown

### consts

#!spiral

inl i_hat () = vec 1 0 0
inl j_hat () = vec 0 1 0
inl k_hat () = vec 0 0 1
inl zero_vec () = vec 0 0 0

#!markdown

### ^+^

#!spiral

inl (^+^) (a : vec) (b : vec) =
    vec (a.x + b.x) (a.y + b.y) (a.z + b.z)

#!spiral

// // test

vec 1 2 3 ^+^ vec 4 5 6
|> _equal (vec 5 7 9)

#!markdown

### sum_vec

#!spiral

inl sum_vec vs =
    vs |> listm.fold (^+^) (zero_vec ())

#!spiral

// // test

[vec 1 2 3; vec 4 5 6]
|> sum_vec
|> _equal (vec 5 7 9)

#!markdown

### *^

#!spiral

inl (*^) c { x y z } =
    vec (c * x) (c * y) (c * z)

#!spiral

// // test

5 *^ vec 1 2 3
|> _equal (vec 5 10 15)

#!markdown

### ^*

#!spiral

inl (^*) v c =
    (*^) c v

#!spiral

// // test

vec 1 2 3 ^* 5
|> _equal (vec 5 10 15)

#!markdown

### ^/

#!spiral

inl (^/) { x y z } c =
    vec (x / c) (y / c) (z / c)

#!spiral

// // test

vec 1 2 3 ^/ 5
|> _equal (vec 0.2 0.4 0.6)

#!markdown

### negate_vec

#!spiral

inl negate_vec v =
    v ^* -1

#!spiral

// // test

vec 1 2 3
|> negate_vec
|> _equal (vec -1 -2 -3)

#!markdown

### ^-^

#!spiral

inl (^-^) a b =
    a ^+^ (negate_vec b)

#!spiral

// // test

vec 1 2 3 ^-^ vec 4 5 6
|> _equal (vec -3 -3 -3)

#!markdown

### <.>

#!spiral

inl (<.>) { x = ax y = ay z = az } { x = bx y = by z = bz } =
    ax * bx + ay * by + az * bz

#!spiral

// // test

vec 1 2 3 <.> vec 4 5 6
|> _equal 32

#!markdown

### \>\<

#!spiral

inl (><) (a : vec) (b : vec) =
    vec
        (a.y * b.z - a.z * b.y)
        (a.z * b.x - a.x * b.z)
        (a.x * b.y - a.y * b.x)

#!spiral

// // test

vec 1 2 3 >< vec 4 5 6
|> _equal (vec -3 6 -3)

#!markdown

### magnitude

#!spiral

inl magnitude v =
    v <.> v |> sqrt

#!spiral

// // test

vec 1 2 3
|> magnitude
|> _almost_equal 3.7416573867739413

#!markdown

### v1

#!spiral

inl v1 t =
    2 *^ (t ** 2 *^ i_hat () ^+^ 3 *^ (t ** 3 *^ j_hat () ^+^ t ** 4 *^ k_hat ()))

#!spiral

// // test

v1 1
|> _equal (vec 2 6 6)

#!markdown

### vec_derivative

#!spiral

type vec_derivative = (f64 -> vec) -> f64 -> vec

inl vec_derivative dt : vec_derivative =
    fun v t =>
        (v (t + dt / 2) ^-^ v (t - dt / 2)) ^/ dt

#!spiral

// // test

vec_derivative 0.01 v1 3 .x
|> _almost_equal (derivative 0.01 (v1 >> fun v => v.x) 3)

#!spiral

// // test

()
