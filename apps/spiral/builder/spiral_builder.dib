#!meta

{"kernelInfo":{"defaultKernelName":"spiral","items":[]}}

#!markdown

# spiral_builder

#!spiral

open file_system_operators
open rust_operators
open sm'_operators

#!spiral

//// test

open testing

#!markdown

## types

#!spiral

inl types () =
    rust.types ()
    sm'.types ()
    file_system.types ()
    runtime.types ()

#!markdown

## get_command_args

#!spiral

inl get_command_args () =
    {
        file = "file"
        out_dir = "out-dir"
        hash = "hash"
        args = "args"
        trace_level = "trace-level"
    }

#!markdown

## get_command

#!spiral

let get_command () =
    ##"command"
    |> runtime.new_command
    |> runtime.command_arg (
        runtime.new_arg ##(get_command_args () .file)
        |> runtime.arg_short 'f'
        |> runtime.arg_long ##(get_command_args () .file)
        |> runtime.arg_required true
    )
    |> runtime.command_arg (
        runtime.new_arg ##(get_command_args () .out_dir)
        |> runtime.arg_short 'o'
        |> runtime.arg_long ##(get_command_args () .out_dir)
        |> runtime.arg_required true
    )
    |> runtime.command_arg (
        runtime.new_arg ##(get_command_args () .hash)
        |> runtime.arg_short 'h'
        |> runtime.arg_long ##(get_command_args () .hash)
        |> runtime.arg_required true
    )
    |> runtime.command_arg (
        runtime.new_arg ##(get_command_args () .args)
        |> runtime.arg_short 'a'
        |> runtime.arg_long ##(get_command_args () .args)
    )
    |> runtime.command_arg (
        runtime.new_arg ##(get_command_args () .trace_level)
        |> runtime.arg_short 't'
        |> runtime.arg_long ##(get_command_args () .trace_level)
        |> runtime.arg_value_parser (
            real get_union_fields_untag `trace_level ()
            |> fun x => x : list trace_level
            |> listm.map to_string
            |> listm'.box
            |> listm'.to_array'
            |> fun (a x : _ i32 _) => x
            |> runtime.value_parser_possible_values
        )
    )

#!markdown

## get_subcommands_args

#!spiral

inl get_subcommands_args () =
    {
        rust = "rust", {
            deps = "deps"
        }
    }

#!markdown

## get_subcommands

#!spiral

let get_subcommands () =
    ##"command"
    |> runtime.new_command
    |> runtime.command_subcommand_required true
    |> runtime.command_subcommand (
        ##(get_subcommands_args () .rust |> fst)
        |> runtime.new_command
        |> runtime.command_arg (
            runtime.new_arg ##((get_subcommands_args () .rust |> snd).deps)
            |> runtime.arg_short 'd'
            |> runtime.arg_long ##((get_subcommands_args () .rust |> snd).deps)
            |> runtime.arg_value_names ;[ ##"NAME"; ##"VERSION" ]
            |> runtime.arg_num_args_range (runtime.new_value_range (am'.Start 1i32) (am'.End id))
        )
    )

#!spiral

inl get_cargo_toml_content hash : string =
    $'$"""[package]\nname = \"{!hash}\"\nversion = "0.0.1"\nedition = "2021"\n\n[workspace]\n\n[dependencies]\nfable_library_rust = {{ path = \"fable_modules/fable-library-rust\", default-features = false, features = [\"static_do_bindings\", \"datetime\", \"guid\", \"threaded\"] }}\nclap = \"~4.5\"\ninline_colorization = \"~0.1\"\nregex = \"~1.10\"\nchrono = \"~0.4\"\nnum-complex = \"~0.4\"\npyo3 = \"~0.21\"\nasync-std = \"~1.12\"\nfutures = \"~0.3\"\nfutures-lite = \"~2.3\"\nasync-walkdir = \"~1.0\"\nrayon = \"~1.10\"\n\n[[bin]]\nname = \"{!hash}\"\npath = \"{!hash}.rs\" """'

#!markdown

## run

#!spiral

let run { file out_dir hash args }
    : async.future_pin (resultm.result' string sm'.std_string) =

    inl file = file |> file_system.get_full_path
    inl out_dir = out_dir |> file_system.get_full_path

    trace Debug
        fun () => $'"spiral_builder.run"'
        fun () => $'$"file: {!file} / out_dir: {!out_dir} / hash: {!hash} / args: {!args} / {!_locals ()}"'

    fun () =>
        inl subcommands =
            get_subcommands ()
            |> runtime.command_get_matches_from ($'$"spiral_builder {!args}"' |> runtime.split_args)

        inl result =
            match subcommands |> runtime.matches_subcommand |> optionm'.unbox with
            | Some (subcommand, arg_matches)
                when sm'.from_std_string subcommand = (get_subcommands_args () .rust |> fst)
                =>
                inl deps : optionm'.option' (am'.vec sm'.std_string) =
                    arg_matches
                    |> runtime.matches_get_many ((get_subcommands_args () .rust |> snd).deps)

                trace Debug
                    fun () => $'"spiral_builder.run"'
                    fun () => $'$"deps: %A{!deps} / {!_locals ()}"'

                inl cargo_toml_content = hash |> get_cargo_toml_content
                cargo_toml_content

            | Some (subcommand, arg_matches) =>
                trace Debug
                    fun () => $'"spiral_builder.run"'
                    fun () => $'$"subcommand: {!subcommand} / {!_locals ()}"'

                inl cargo_toml_content = hash |> get_cargo_toml_content
                cargo_toml_content
            | _ => ""

        trace Debug
            fun () => $'"spiral_builder.run"'
            fun () => $'$"result: {!result} / {!_locals ()}"'

        result |> Ok |> resultm.box
    |> async.future_init (3, 2) 1

#!spiral

//// test
//// print_code=false
//// trace=false
///! rust

types ()
run {
    file = "file"
    out_dir = "out_dir"
    hash = "hash"
    args = "rust"
}
|> async.block_on
|> resultm.unwrap'
|> _assert_eq (
    "hash"
    |> get_cargo_toml_content
)

#!spiral

//// test
//// print_code=false
//// trace=false
///! rust

types ()
run {
    file = "file"
    out_dir = "out_dir"
    hash = "hash"
    args = "rust --deps"
}
|> async.block_on
|> resultm.unwrap'
|> _assert_eq (
    "hash"
    |> get_cargo_toml_content
)

#!markdown

## tests

#!spiral

inl tests () =
    rust.run_tests [
        "verify_app", fun _ =>
            get_command () |> runtime.command_debug_assert
    ]

#!markdown

## main

#!spiral

///! 

inl main (args : array_base string) =
    inl trace_state = get_trace_state ()
    inl trace_state_level = trace_state.level
    trace_state_level <- Info

    trace Debug
        fun () => $'$"spiral_builder.main"'
        fun () => $'$"args: {!args} / {!_locals ()}"'

    inl command = get_command ()
    inl arg_matches = command |> runtime.command_get_matches

    inl file =
        arg_matches
        |> runtime.matches_get_one (get_command_args () .file)
        |> optionm'.unbox
        |> optionm.value
        |> sm'.from_std_string

    inl out_dir =
        arg_matches
        |> runtime.matches_get_one (get_command_args () .out_dir)
        |> optionm'.unbox
        |> optionm.value
        |> sm'.from_std_string

    inl hash =
        arg_matches
        |> runtime.matches_get_one (get_command_args () .hash)
        |> optionm'.unbox
        |> optionm.value
        |> sm'.from_std_string

    inl args =
        arg_matches
        |> runtime.matches_get_one (get_command_args () .args)
        |> optionm'.unbox
        |> optionm.map sm'.from_std_string
        |> optionm'.default_value ""

    inl trace_level =
        arg_matches
        |> runtime.matches_get_one (get_command_args () .trace_level)
        |> optionm'.unbox
        |> optionm.map sm'.from_std_string

    match trace_level with
    | Some trace_level => trace_state_level <- trace_level |> of_string
    | None => ()

    inl result =
        run { file out_dir hash args }
        |> async.block_on
        |> resultm.unwrap'

    if *trace_state_level = Info
    then result |> console.write_line

    0i32

inl main () =
    types ()
    $"let tests () = !tests ()" : ()
    $"let main args = !main args" : ()
