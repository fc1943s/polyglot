#!meta

{"kernelInfo":{"defaultKernelName":"fsharp","items":[]}}

#!markdown

## Spiral (Polyglot)

#!fsharp

#!import ../nbs/Plotting.dib

#!spiral

// // test

inl _almost_equal b a =
    assert (abs (b - a) < 0.00000001) $"$\"_almost_equal / actual: {!a} / expected: {!b}\""

inl _equal b a =
    assert (a = b) $"$\"_equal / actual: {!a} / expected: {!b}\""

inl _is_less_than b a =
    assert (b < a) $"$\"_is_less_than / actual: {!a} / expected: {!b}\""

inl _is_less_than_or_equal b a =
    assert (b <= a) $"$\"_is_less_than_or_equal / actual: {!a} / expected: {!b}\""

#!spiral

inl init_series start end inc =
    inl total = conv ((end - start) / inc) + 1
    am.init total (conv >> (*) inc >> (+) start) : a i32 f64

#!spiral

inl atan2 (y : f64) (x : f64) =
    $"System.Math.Atan2 (!y, !x)" : f64

inl cos (d : f64) =
    $"System.Math.Cos !d" : f64

inl e () =
    exp 1f64

inl log_base (new_base : f64) (a : f64) =
    $"System.Math.Log (!a, !new_base)" : f64

inl pi () =
    $"System.Math.PI" : f64

inl sin (d : f64) =
    $"System.Math.Sin !d" : f64

inl square x =
    x ** 2

#!spiral

type time = f64
type time_interval = f64
type position = f64
type velocity = f64
type position_fn = time -> position
type velocity_fn = time -> velocity

type derivative = (f64 -> f64) -> f64 -> f64

inl derivative dt : derivative =
    fun x t =>
        (x (t + dt / 2) - x (t - dt / 2)) / dt

type integration = (f64 -> f64) -> f64 -> f64 -> f64

inl integral dt : integration =
    fun f a b =>
        inl total = conv ((b - a) / dt)
        inl items : a i32 f64 =
            am.init total (fun i => a + dt / 2 + conv i * dt)
            |> am.map (f >> (*) dt)
        items
        |> am.fold (+) 0

#!spiral

// // test

2 * 2 / 0.4f64 |> sqrt
|> _almost_equal 3.1622776601683795

#!spiral

// // test

2f64 / 3
|> _almost_equal 0.6666666666666666

#!spiral

// // test

2f64 |> log
|> _almost_equal 0.6931471805599453

#!spiral

// // test

pi ()
|> _almost_equal 3.141592653589793

#!spiral

// // test

pi () |> cos
|> _equal -1

#!spiral

// // test

pi ()
|> cos
|> fun n => n / 2
|> _almost_equal -0.5

#!spiral

// // test

pi () / 2 |> cos
|> _almost_equal 0.00000000000000006123233995736766

#!spiral

// // test

100 |> log_base 10
|> _equal 2

#!spiral

// // test

0 |> atan2 1
|> _equal 1.5707963267948966

#!spiral

// // test

5f64
|> sqrt
|> fun n => n ** 2
|> _almost_equal 5

#!spiral

// // test

e () |> square
|> _almost_equal 7.3890560989306495

#!spiral

// // test

inl x = init_series -3 3 0.01
inl y = x |> am.map square
x, ;[("square", y)]

#!spiral

// // test

inl x = init_series -10 10 0.1
inl y_sin = x |> am.map sin
inl y_cos = x |> am.map cos
x, ;["sin", y_sin; "cos", y_cos]

#!spiral

// // test

derivative 1 (fun x => x ** 4 / 4) 1 - 1
|> _almost_equal 0.25

derivative 0.001 (fun x => x ** 4 / 4) 1 - 1
|> _almost_equal 0.0000002499998827953931

derivative 0.000001 (fun x => x ** 4 / 4) 1 - 1
|> _almost_equal 0.000000000001000088900582341

derivative 0.000000001 (fun x => x ** 4 / 4) 1 - 1
|> _almost_equal 0.00000008274037099909037

derivative 0.000000000001 (fun x => x ** 4 / 4) 1 - 1
|> _almost_equal 0.00008890058234101161

derivative 0.000000000000001 (fun x => x ** 4 / 4) 1 - 1
|> _almost_equal -0.0007992778373592246

derivative 0.000000000000000001 (fun x => x ** 4 / 4) 1 - 1
|> _almost_equal -1

#!spiral

// // test

integral 0.01 (fun x => x ** 2) 0 1
|> _almost_equal 0.33332500000000004

#!spiral

// // test
()

#!spiral

// // test
()

#!spiral

// // test
()

#!spiral

// // test
()

#!spiral

// // test
()
