open rust_operators


type state =
    heap {
        cache : leptos.rw_signal (rust.hash_map rust.std_string (rust.weak_rc (rust.ref_cell (leptos.rw_signal rust.std_string))))
    }

type state_data =
    heap {
        cache : rust.hash_map rust.std_string rust.std_string
    }

type global_state = state_core.global_state state

inl use_database () =
    leptos.log $'"state.use_database (1)"'

    inl state_data_key = state_core.get_state_data_key ()
    inl global_state : global_state = leptos.use_context () |> optionm'.unwrap

    inl database : leptos.resource (option ()) rust.rexie =
        leptos.create_local_resource
            fun () => None
            fun _ =>
                fun () =>
                    leptos.log $'"state.use_database (2) / database create_local_resource"'
                    state_core.build_database () |> async.await |> resultm.get
                |> async.future_init 6 0

    inl _ = state_core.use_core_database database global_state

    let (loaded, set_loaded) = leptos.create_signal false

    inl state_data : leptos.resource (optionm'.option' rust.rexie) (option state_data) =
        leptos.create_local_resource
            fun () =>
                database
                |> leptos.resource_get
            fun (database : optionm'.option' rust.rexie) =>
                fun () =>
                    inl database_log = database |> sm'.format_debug
                    leptos.log $'"state.use_database (3) / state_data create_local_resource / database: " + !database_log + ""'
                    match database |> optionm'.unbox with
                    | Some database =>
                        database
                        |> state_core.get_data state_data_key
                        |> async.await
                        |> resultm.unbox
                        |> resultm.get
                    | None => None
                |> async.future_init 4 0

    inl new_signal_map : leptos.memo (optionm'.option' (rust.hash_map rust.std_string (rust.rc (rust.ref_cell (leptos.rw_signal rust.std_string))))) =
        leptos.create_memo fun () =>
            leptos.log $'"state.use_database (4) / new_signal_map memo"'

            match leptos.window () |> store.local_storage |> resultm.unbox |> resultm.map optionm'.unbox with
            | Ok (Some _storage) =>
                inl state_data = state_data |> leptos.resource_get |> optionm'.unbox |> optionm'.flatten
                inl state_data_len : i64 = state_data |> sm'.format_debug |> sm.length
                leptos.log $'"state.use_database (5) / new_signal_map memo / state_data: " + string !state_data_len + ""'

                match state_data with
                | Some state_data =>
                    state_data.cache
                    |> mapm.map fun value =>
                        inl value = join value
                        value
                        |> leptos.create_rw_signal
                        |> rust.new_ref_cell
                        |> rust.new_rc
                    |> Some
                | _ => None
            | _ => None
            |> optionm'.box

    leptos.create_effect fun () =>
        leptos.log $'"state.use_database (6) / effect state_data / ##1"'

        inl new_signal_map =
            new_signal_map
            |> leptos.memo_get
            |> optionm'.unbox

        match new_signal_map with
        | Some new_signal_map =>
            rust.move fun () =>
                leptos.log $'"state.use_database (7) / effect state_data / ##2"'
                leptos.signal_get global_state.state .cache
                |> leptos.signal_update fun _ =>
                    leptos.log $'"state.use_database (8) / effect state_data / state.cache signal_update"'
                    new_signal_map
                    |> mapm.map fun value =>
                        inl value = join value
                        value
                        |> rust.rc_downgrade
            |> leptos.batch
            leptos.log $'"state.use_database (9) / effect state_data / ##3"'
        | None => ()

    inl set_state_data_action = leptos.create_action fun value =>
        inl value_len : i64 = value |> sm'.format_debug |> sm.length
        inl database =
            database
            |> leptos.resource_get
            |> optionm'.unbox
        fun () =>
            match database with
            | Some database =>
                leptos.log $'"state.use_database (10) / set_state_data_action / database=Some(_) / value_len: " + string !value_len + ""'
                database
                |> state_core.set_data state_data_key value
                |> async.await
                |> resultm.unbox
                |> resultm.get
            | None => leptos.log $'"state.use_database (11) / set_state_data_action / database=None"'
        |> async.future_init 1 1

    leptos.create_effect fun () =>
        inl loaded = loaded |> leptos.signal_get
        leptos.log $'"state.use_database (12) / effect new_state_data / ##1 / loaded: " + string !loaded + ""'

        inl new_state_data : state_data =
            heap {
                cache =
                    leptos.signal_get global_state.state .cache
                    |> leptos.signal_get
                    |> mapm.map (
                        optionm'.rc_upgrade
                        >> optionm.map (rust.ref_cell_borrow >> leptos.signal_get)
                        >> optionm'.default_value ("" |> sm'.to_std_string)
                    )
            }

        inl new_state_data_len : i64 = new_state_data |> sm'.format_debug |> sm.length
        leptos.log $'"state.use_database (13) / effect new_state_data / ##2 / new_state_data_len: " + string !new_state_data_len + ""'
        if not loaded then
            set_loaded
            |> leptos.signal_update fun _ =>
                leptos.log $'"state.use_database (14) / effect new_state_data / set_loaded |> signal_update true"'
                true
        else
            leptos.log $'"state.use_database (15) / effect new_state_data / ##4"'

            match leptos.window () |> store.local_storage |> resultm.unbox |> resultm.map optionm'.unbox with
            | Ok (Some storage) =>
                set_state_data_action |> leptos.action_dispatch new_state_data
            | _ => ()

            leptos.log $'"state.use_database (16) / effect new_state_data / ##5"'

    database

inl use_request forall t u.
    (url : () -> optionm'.option' string)
    (map : u -> t)
    : rust.func0 (option (result t rust.std_string))
    =

    inl global_state : global_state = leptos.use_context () |> optionm'.unwrap

    inl json
        : leptos.resource
            (optionm'.option' string)
            (resultm.result' (optionm'.option' string) string)
        =
        leptos.create_local_resource
            fun () => url ()
            fun url =>
                inl url_log = url |> sm'.format_debug
                leptos.log $'"use_request (1) / json create_local_resource / url: " + string !url_log + ""'
                fun () =>
                    match url |> optionm'.unbox with
                    | Some url =>
                        url
                        |> networking.new_request_get
                        |> async.await
                        |> resultm.map_error' sm'.format'
                        |> resultm.try'
                        |> networking.response_text
                        |> async.await
                        |> resultm.map_error' sm'.format'
                        |> resultm.try'
                        |> sm'.from_std_string
                        |> Some
                    | None => None
                    |> optionm'.box
                    |> Ok
                    |> resultm.box
                |> async.future_init 3 1

    inl signal : leptos.memo (optionm'.option' (rust.rc (rust.ref_cell (leptos.rw_signal rust.std_string)))) =
        leptos.create_memo fun () =>
            inl url = url ()
            inl url_log = url |> sm'.format_pretty'
            leptos.log $'"use_request (2) / signal memo / url: " + string !url_log + ""'

            match url |> optionm'.unbox with
            | Some url =>
                inl cache =
                    leptos.signal_get global_state.state .cache
                    |> leptos.signal_get
                inl key = url |> sm'.to_std_string
                cache
                |> mapm.get key
                |> optionm'.unbox
                |> function
                    | Some set_cache =>
                        leptos.log $'"use_request (2.1) / signal memo / rc_upgrade"'
                        set_cache
                        |> optionm'.rc_upgrade
                    | None =>
                        leptos.log $'"use_request (2.1) / signal memo / \\\"\\\" |> create_rw_signal"'
                        ""
                        |> sm'.to_std_string
                        |> leptos.create_rw_signal
                        |> rust.new_ref_cell
                        |> rust.new_rc
                        |> Some
            | _ => None
            |> optionm'.box

    leptos.create_effect fun () =>
        inl url = url ()
        inl url_log = url |> sm'.format_pretty'
        leptos.log $'"use_request (3) / effect / url: " + string !url_log + ""'

        inl signal = signal |> leptos.memo_get |> optionm'.unbox

        inl json =
            json
            |> leptos.resource_get
            |> optionm'.unbox
            |> optionm.map resultm.unbox
            |> optionm.map (resultm.map optionm'.unbox)
            |> resultm.flatten_option

        inl signal_log = signal |> sm'.format_debug
        inl json_len : i64 = json |> sm'.format_debug |> sm.length
        leptos.log $'"use_request (4) / effect / json_len: " + string !json_len + " / signal: " + string !signal_log + ""'

        match json, signal, url |> optionm'.unbox with
        | Some (Ok json), Some signal, Some url =>
            rust.move fun () =>
                inl cache =
                    leptos.signal_get global_state.state .cache
                    |> leptos.signal_get
                inl key = url |> sm'.to_std_string
                inl value = json |> sm'.to_std_string

                signal
                |> rust.ref_cell_borrow
                |> leptos.signal_update fun _ =>
                    leptos.log $'"use_request (5) / effect / signal signal_update"'
                    value

                cache |> mapm.insert key (signal |> rust.rc_downgrade)

                |> ignore

                leptos.signal_get global_state.state .cache
                |> leptos.signal_update fun _ =>
                    leptos.log $'"use_request (6) / effect / state.cache signal_update"'
                    cache
            |> leptos.batch
        | _ => ()

    inl result : leptos.memo (resultm.result' (optionm'.option' u) rust.std_string) =
        leptos.create_memo fun () =>
            inl url = url ()
            inl url_log = url |> sm'.format_pretty'
            leptos.log $'"use_request (7) / result memo / url: " + string !url_log + ""'

            inl json_cache =
                match url |> optionm'.unbox with
                | Some url =>
                    leptos.log $'"use_request (8) / result memo / url: " + string !url + ""'
                    leptos.signal_get global_state.state .cache
                    |> leptos.signal_get
                    |> mapm.get (url |> sm'.to_std_string)
                    |> optionm'.map (optionm'.rc_upgrade >> optionm.map rust.ref_cell_borrow)
                    |> optionm'.unbox
                    |> optionm'.flatten
                    |> optionm.map
                        (leptos.signal_get >> sm'.from_std_string >> sm'.deserialize >> resultm.try')
                | None => None

            json_cache
            |> optionm'.box
            |> Ok
            |> resultm.box
            |> fun result =>
                inl result_len : i64 = result |> sm'.format_debug |> sm.length
                leptos.log $'"use_request (9) / result create_memo / result_len: " + string !result_len + ""'
                result

    inl result : rust.func0 (option (result t rust.std_string)) =
        rust.move fun () =>
            leptos.log $'"use_request (10) / result move"'
            result
            |> leptos.memo_get
            |> resultm.unbox
            |> resultm.map fun result =>
                result
                |> optionm'.unbox
                |> optionm.map map
            |> function
                | Ok (Some x) => Some (Ok x)
                | Error x => Some (Error x)
                | _ => None
            |> fun result =>
                inl result_len : i64 = result |> sm'.format_debug |> sm.length
                leptos.log $'"use_request (11) / result move / result_len: " + string !result_len + ""'
                result

    result
