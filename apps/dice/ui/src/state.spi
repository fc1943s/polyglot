open rust_operators

inl types () =
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"js_sys::Function\")>] type js_sys_Function = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"js_sys::JsString\")>] type js_sys_JsString = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::ev::Event\")>] type leptos_ev_Event = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::ev::MouseEvent\")>] type leptos_ev_MouseEvent = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::html::A\")>] type leptos_html_A = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::html::AnyElement\")>] type leptos_html_AnyElement = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::html::Button\")>] type leptos_html_Button = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::html::Details\")>] type leptos_html_Details = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::html::Dd\")>] type leptos_html_Dd = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::html::Div\")>] type leptos_html_Div = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::html::Dl\")>] type leptos_html_Dl = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::html::Dt\")>] type leptos_html_Dt = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::html::Input\")>] type leptos_html_Input = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::html::Label\")>] type leptos_html_Label = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::html::Nav\")>] type leptos_html_Nav = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::html::Option_\")>] type leptos_html_Option = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::html::Pre\")>] type leptos_html_Pre = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::html::Select\")>] type leptos_html_Select = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::svg::Svg\")>] type leptos_svg_Svg = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::leptos_dom::Text\")>] type leptos_dom_Text = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::leptos_dom::Transparent\")>] type leptos_dom_Transparent = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos_router::Route\")>] type leptos_router_Route = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos_router::RouteDefinition\")>] type leptos_router_RouteDefinition = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos_router::Router\")>] type leptos_router_Router = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos_router::Routes\")>] type leptos_router_Routes = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::Action<$0, $1>\")>] type leptos_Action<'T, 'U> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::Fragment\")>] type leptos_Fragment = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::HtmlElement<$0>\")>] type leptos_HtmlElement<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::IntoView\")>] type leptos_IntoView = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos_router::Location\")>] type leptos_router_Location = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos_router::NavigateOptions\")>] type leptos_router_NavigateOptions = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos_router::Url\")>] type leptos_router_Url = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::Memo<$0>\")>] type leptos_Memo<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::RwSignal<$0>\")>] type leptos_RwSignal<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::ReadSignal<$0>\")>] type leptos_ReadSignal<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::Resource<$0, $1>\")>] type leptos_Resource<'T, 'U> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::WriteSignal<$0>\")>] type leptos_WriteSignal<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::View\")>] type leptos_View = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"borsh::io::Error\")>] type borsh_io_Error = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"rexie::Error\")>] type rexie_Error = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"rexie::Rexie\")>] type rexie_Rexie = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"rexie::Store\")>] type rexie_Store = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"rexie::Transaction\")>] type rexie_Transaction = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"serde_json::Error\")>] type serde_json_Error = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"serde_json::Value\")>] type serde_json_Value = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"std::any::Any\")>] type std_any_Any = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"std::collections::HashMap<$0, $1>\")>] type std_collections_HashMap<'K, 'V> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"std::future::Future<Output = $0>\")>] type Future<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"std::pin::Pin<$0>\")>] type std_pin_Pin<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"std::rc::Rc<$0>\")>] type std_rc_Rc<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"std::string::String\")>] type std_string_String = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"std::sync::Arc<$0>\")>] type std_sync_Arc<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"wasm_bindgen::JsValue\")>] type wasm_bindgen_JsValue = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"wasm_bindgen::closure::Closure<$0>\")>] type wasm_bindgen_closure_Closure<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"web_sys::Document\")>] type web_sys_Document = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"web_sys::HtmlElement\")>] type web_sys_HtmlElement = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"web_sys::Storage\")>] type web_sys_Storage = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"web_sys::Window\")>] type web_sys_Window = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"Box<$0>\")>] type Box<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"dyn $0\")>] type Dyn<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"Fn() -> $0\")>] type Fn<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"Fn()\")>] type FnUnit = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"FnOnce() -> $0\")>] type FnOnce<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"Fn($0, $1)\")>] type ActionFn2<'T, 'U> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"impl $0\")>] type Impl<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"mut $0\")>] type Mut<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"&$0\")>] type Ref<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"&'static $0\")>] type StaticRef<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"str\")>] type Str = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"Vec<$0>\")>] type Vec<'T> = class end"

type core_state =
    heap {
        dark_mode : leptos.rw_signal bool
        url_hash : leptos.rw_signal rust.std_string
    }

type core_state_data =
    heap {
        dark_mode : bool
        url_hash : rust.std_string
    }

type state =
    heap {
        explorer_backend_host : leptos.rw_signal rust.std_string
    }

type state_data =
    heap {
        explorer_backend_host : rust.std_string
    }


type global_state =
    heap {
        core_state : leptos.rw_signal core_state
        state : leptos.rw_signal state
        loading : leptos.rw_signal (rust.hash_map rust.std_string (leptos.rw_signal bool))
    }

inl build_database () : rust.pin (rust.box (rust.dyn' (rust.future (result rust.rexie rust.rexie_error)))) =
    leptos.log $'"state.build_database ()"'

    fun () =>
        inl rexie : rust.pin (rust.box (rust.dyn' (rust.future (resultm.result' rust.rexie rust.rexie_error)))) = !\($'"Box::pin(rexie::Rexie::builder(\\\"database\\\").version(1).add_object_store(rexie::ObjectStore::new(\\\"store\\\")).build())"')
        inl rexie : resultm.result' rust.rexie rust.rexie_error = rexie |> async.await
        inl rexie : rust.rexie = rexie |> resultm.unbox |> resultm.get
        Ok rexie
    |> async.future_init 1 0

inl get_core_state_data_key () =
    "core-state-data"

inl get_state_data_key () =
    "state-data"

inl get_data forall t. (id : string) (rexie : rust.rexie) : rust.pin (rust.box (rust.dyn' (rust.future (resultm.result' (option t) rust.rexie_error)))) =
    leptos.log $'"state.get_data () / id: " + !id + ""'
    inl rexie = join rexie
    fun () =>
        inl transaction : rust.rexie_transaction = !\($'"!rexie.transaction(&[\\\"store\\\"], rexie::TransactionMode::ReadOnly)?"')
        inl rexie_store : rust.rexie_store = !\($'"!transaction.store(\\\"store\\\")?"')
        inl mode_value : resultm.result' rust.js_value rust.rexie_error = rexie_store |> store.store_get id |> async.await
        inl mode_value : rust.js_value = mode_value |> resultm.try'
        inl mode_data : optionm'.option' rust.json_value = !\($'"serde_wasm_bindgen::from_value(!mode_value).unwrap()"')
        match mode_data |> optionm'.unbox with
        | Some mode_data =>
            inl mode_data = join mode_data
            inl data : rust.vec u8 = !\($'"serde_json::from_value(!mode_data).unwrap()"')
            inl data_log = data |> format_debug
            leptos.log $'"state.get_data () / data: " + string !data_log + ""'
            inl data = join data
            inl data : resultm.result' t (rust.arc rust.borsh_io_error) = !\($'"borsh::BorshDeserialize::deserialize(&mut !data.as_slice()).map_err(|x| std::sync::Arc::new(x))"')
            inl data_log = data |> sm'.format_pretty
            leptos.log $'"state.get_data () / data: " + string !data_log + ""'
            data |> resultm.ok' |> optionm'.unbox |> Ok
        | None => Ok None
        |> resultm.box
    |> async.future_init 2 0

inl set_data forall t. (id : string) (data : t) (rexie : rust.rexie) : rust.pin (rust.box (rust.dyn' (rust.future (resultm.result' () rust.rexie_error)))) =
    inl data_log = data |> sm'.format_debug
    leptos.log $'"state.set_data () / data: " + string !data_log + ""'
    inl rexie = join rexie
    fun () =>
        inl transaction : rust.rexie_transaction = !\($'"!rexie.transaction(&[\\\"store\\\"], rexie::TransactionMode::ReadWrite)?"')
        inl store : rust.rexie_store = !\($'"!transaction.store(\\\"store\\\")?"')

        !\($'"let mut data = Vec::new()"')
        !\($'"borsh::BorshSerialize::serialize(&!data, &mut data).unwrap()"')
        inl data : rust.vec u8 = !\($'"data"')

        inl data_js_value : rust.js_value = !\($'"serde_wasm_bindgen::to_value(&!data).unwrap()"')
        inl id = id |> sm'.as_str
        !\($'"!store.put(&!data_js_value, Some(&!id.into())).await?"')
        !\($'"!transaction.done().await?"')

        Ok () |> resultm.box
    |> async.future_init 6 0

inl use_database () =
    leptos.log $'"state.use_database ()"'

    inl core_state_data_key = get_core_state_data_key ()
    inl state_data_key = get_state_data_key ()
    inl global_state : global_state = leptos.use_context () |> optionm'.unwrap

    inl database : leptos.resource (option ()) rust.rexie =
        leptos.create_local_resource
            fun () => None
            fun _ =>
                fun () =>
                    leptos.log $'"state.use_database () / database create_local_resource"'
                    build_database () |> async.await |> resultm.get
                |> async.future_init 0 0

    inl core_state_data : leptos.resource (optionm'.option' rust.rexie) (option core_state_data) =
        leptos.create_local_resource
            fun () =>
                database
                |> leptos.resource_get
            fun (database : optionm'.option' rust.rexie) =>
                fun () =>
                    inl database_log = database |> format_debug
                    leptos.log $'"state.use_database () / core_state_data create_local_resource / database: " + string !database_log + ""'
                    match database |> optionm'.unbox with
                    | Some database =>
                        database
                        |> get_data core_state_data_key
                        |> async.await
                        |> resultm.unbox
                        |> resultm.get
                    | None => None
                |> async.future_init 3 0

    inl state_data : leptos.resource (optionm'.option' rust.rexie) (option state_data) =
        leptos.create_local_resource
            fun () =>
                database
                |> leptos.resource_get
            fun (database : optionm'.option' rust.rexie) =>
                fun () =>
                    inl database_log = database |> format_debug
                    leptos.log $'"state.use_database () / state_data create_local_resource / database: " + string !database_log + ""'
                    match database |> optionm'.unbox with
                    | Some database =>
                        database
                        |> get_data state_data_key
                        |> async.await
                        |> resultm.unbox
                        |> resultm.get
                    | None => None
                |> async.future_init 3 0

    leptos.create_effect fun () =>
        leptos.log $'"state.use_database () / effect core_state_data / ##1"'

        match leptos.window () |> store.local_storage |> resultm.unbox |> resultm.map optionm'.unbox with
        | Ok (Some storage) =>
            inl core_state_data = core_state_data |> leptos.resource_get |> optionm'.unbox
            inl core_state_data_log = core_state_data |> format_debug
            leptos.log $'"state.use_database () / effect core_state_data / ##2 / core_state_data: " + string !core_state_data_log + ""'

            inl core_state_data =
                match core_state_data with
                | Some (Some core_state_data) =>
                    Some core_state_data
                | _ =>
                    storage
                    |> store.storage_get core_state_data_key
                    |> resultm.ok
                    |> optionm'.flatten
                    |> optionm.map fun (value : rust.std_string) =>
                        inl value = join value
                        value |> sm'.from_std_string |> sm'.deserialize |> resultm.ok' |> optionm'.unbox
                    |> optionm'.flatten

            inl core_state_data_log = core_state_data |> format_debug
            leptos.log $'"state.use_database () / effect core_state_data / ##3 / core_state_data: " + string !core_state_data_log + ""'

            match core_state_data with
            | Some core_state_data =>
                leptos.rw_signal_get_untracked global_state.core_state .dark_mode
                |> leptos.rw_signal_update fun _ => core_state_data.dark_mode

                leptos.rw_signal_get_untracked global_state.core_state .url_hash
                |> leptos.rw_signal_update fun _ => core_state_data.url_hash
            | _ => ()
        | _ => ()

    leptos.create_effect fun () =>
        leptos.log $'"state.use_database () / effect state_data / ##1"'

        match leptos.window () |> store.local_storage |> resultm.unbox |> resultm.map optionm'.unbox with
        | Ok (Some _storage) =>
            inl state_data = state_data |> leptos.resource_get |> optionm'.unbox |> optionm'.flatten
            inl state_data_log = state_data |> format_debug
            leptos.log $'"state.use_database () / effect state_data / ##2 / state_data: " + string !state_data_log + ""'

            inl state_data_log = state_data |> format_debug
            leptos.log $'"state.use_database () / effect state_data / ##3 / state_data: " + string !state_data_log + ""'

            match state_data with
            | Some state_data =>
                leptos.rw_signal_get_untracked global_state.state .explorer_backend_host
                |> leptos.rw_signal_update fun _ => state_data.explorer_backend_host
            | _ => ()
        | _ => ()

    inl set_core_state_data_action = leptos.create_action fun value =>
        inl value_log = value |> sm'.format_debug
        inl database =
            database
            |> leptos.resource_get
            |> optionm'.unbox
        fun () =>
            match database with
            | Some database =>
                leptos.log $'"state.use_database () / set_core_state_data_action / value: " + string !value_log + ""'
                database
                |> set_data core_state_data_key value
                |> async.await
                |> resultm.unbox
                |> resultm.get
            | None => leptos.log $'"state.use_database () / set_core_state_data_action / database=None"'
        |> async.future_init 7 1

    inl set_state_data_action = leptos.create_action fun value =>
        inl value_log = value |> sm'.format_debug
        inl database =
            database
            |> leptos.resource_get
            |> optionm'.unbox
        fun () =>
            match database with
            | Some database =>
                leptos.log $'"state.use_database () / set_state_data_action / database=Some(_) / value: " + string !value_log + ""'
                database
                |> set_data state_data_key value
                |> async.await
                |> resultm.unbox
                |> resultm.get
            | None => leptos.log $'"state.use_database () / set_state_data_action / database=None"'
        |> async.future_init 7 1

    let loading = leptos.create_memo fun () =>
        leptos.log $'"state.use_database () / loading create_memo"'
        global_state.loading |> leptos.rw_signal_get_untracked

    let (loaded, set_loaded) = leptos.create_signal false

    leptos.create_effect fun () =>
        inl loaded = loaded |> leptos.signal_get
        leptos.log $'"state.use_database () / effect new_core_state_data / ##1 / loaded: " + string !loaded + ""'

        inl new_core_state_data =
            heap {
                dark_mode =
                    leptos.rw_signal_get_untracked global_state.core_state .dark_mode
                    |> leptos.rw_signal_get

                url_hash =
                    leptos.rw_signal_get_untracked global_state.core_state .url_hash
                    |> leptos.rw_signal_get
            }

        inl new_core_state_data_log = new_core_state_data |> sm'.format_debug
        leptos.log $'"state.use_database () / effect new_core_state_data / ##2 / new_core_state_data: " + string !new_core_state_data_log + ""'

        inl dark_mode_loading =
            loading
            |> leptos.memo_get
            |> mapm.get ("dark_mode_key" |> sm'.to_std_string)
            |> optionm'.unbox
            |> optionm.map leptos.rw_signal_get
            |> optionm'.default_value false

        leptos.log $'"state.use_database () / effect new_core_state_data / ##3 / dark_mode_loading: " + string !dark_mode_loading + ""'

        if not dark_mode_loading then
            if not loaded
            then true |> leptos.signal_set set_loaded
            else
                leptos.log $'"state.use_database () / effect new_core_state_data / ##4"'

                match leptos.window () |> store.local_storage |> resultm.unbox |> resultm.map optionm'.unbox with
                | Ok (Some storage) =>
                    set_core_state_data_action |> leptos.action_dispatch new_core_state_data
                    storage |> store.storage_set core_state_data_key new_core_state_data
                | _ => ()

    leptos.create_effect fun () =>
        inl loaded = loaded |> leptos.signal_get
        leptos.log $'"state.use_database () / effect new_state_data / ##1 / loaded: " + string !loaded + ""'

        inl new_state_data =
            heap {
                explorer_backend_host =
                    leptos.rw_signal_get_untracked global_state.state .explorer_backend_host
                    |> leptos.rw_signal_get
            }

        inl new_state_data_log = new_state_data |> sm'.format_debug
        leptos.log $'"state.use_database () / effect new_state_data / ##2 / new_state_data: " + string !new_state_data_log + ""'
        if not loaded
        then true |> leptos.signal_set set_loaded
        else
            leptos.log $'"state.use_database () / effect new_state_data / ##4"'

            match leptos.window () |> store.local_storage |> resultm.unbox |> resultm.map optionm'.unbox with
            | Ok (Some storage) =>
                set_state_data_action |> leptos.action_dispatch new_state_data
            | _ => ()

    database
