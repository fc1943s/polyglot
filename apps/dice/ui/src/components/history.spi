open rust_operators
open model.near.backend

inl types () =
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"reqwest_wasm::Response\")>] type reqwest_Response = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"reqwest_wasm::Error\")>] type reqwest_Error = class end"

nominal reqwest_response = $"reqwest_Response"
nominal reqwest_error = $"reqwest_Error"

inl new_request_get (url : string) : rust.pin (rust.box (rust.dyn' (rust.future (resultm.result' reqwest_response reqwest_error)))) =
    inl url = join url
    inl url = url |> sm'.to_std_string
    inl url = join url
    !\($'"Box::pin(reqwest_wasm::Client::builder().build().map_err(|err| err.to_string())?.get(!url).send())"')

inl response_text (response : reqwest_response) : rust.pin (rust.box (rust.dyn' (rust.future (resultm.result' rust.std_string reqwest_error)))) =
    !\($'"Box::pin(reqwest_wasm::Response::text(!response))"')

inl render () =
    leptos.log $'"history.render ()"'

    inl global_state : state.global_state = leptos.use_context () |> optionm'.unwrap

    inl url_input = leptos.create_memo fun () =>
        inl id = "i574n.near"

        inl input_obj : rust.hash_map rust.std_string (rust.rc input_data') =
            ;[
                "0" |> sm'.to_std_string,
                IdInput { id = id |> sm'.to_std_string } |> input_data_box |> rust.new_rc

                "1" |> sm'.to_std_string,
                IdInput { id = id |> sm'.to_std_string } |> input_data_box |> rust.new_rc

                "2" |> sm'.to_std_string,
                TransactionListByAccountIdInput
                    {
                        account_id = id |> sm'.to_std_string
                        limit = 10
                        cursor = None
                    }
                |> input_data_box |> rust.new_rc
            ]
            |> mapm.from_array

        inl input_json : resultm.result' rust.std_string rust.json_error = !\($'"serde_json::to_string(&!input_obj)"')
        inl input_json = input_json |> resultm.unwrap'
        inl input : rust.js_string = !\($'"js_sys::encode_uri_component(&!input_json)"')
        input |> sm'.format

    inl url = leptos.create_memo fun () =>
        inl explorer_backend_host =
            leptos.rw_signal_get_untracked global_state.state .explorer_backend_host
            |> leptos.rw_signal_get

        inl url_input = url_input |> leptos.memo_get

        inl url : string = $'"https://" + string !explorer_backend_host + "/trpc/account.transactionsCount,contract.byId,transaction.listByAccountId?batch=1&input=" + string !url_input + ""'
        leptos.log $'"history.render () / url: " + !url + ""'
        url

    inl json : leptos.resource string (resultm.result' string string) =
        leptos.create_local_resource
            fun () => url |> leptos.memo_get
            fun url =>
                fun () =>
                    leptos.log $'"history.render () / response create_local_resource"'
                    url
                    |> new_request_get
                    |> async.await
                    |> resultm.map_error' sm'.format
                    |> resultm.try'
                    |> response_text
                    |> async.await
                    |> resultm.map_error' sm'.format
                    |> resultm.try'
                    |> sm'.from_std_string
                    |> Ok
                    |> resultm.box
                |> async.future_init 2 0

    inl result_wrapper : leptos.memo (resultm.result' (a i32 result_wrapper') string) =
        leptos.create_memo fun () =>
            json
            |> leptos.resource_get
            |> optionm'.unbox
            |> optionm.map resultm.unbox
            |> resultm.flatten_option
            |> resultm.map fun json =>
                json
                |> sm'.deserialize
                |> resultm.map_error' sm'.format
                |> resultm.try'
                |> am'.from_vec
            |> resultm.box

    ;[
        leptos.accordion "History" true fun () =>
            "{}" |> leptos.text_fragment
        |> leptos.element_to_view

        if leptos.rw_signal_get_untracked global_state.core_state .debug |> leptos.rw_signal_get then
            leptos.accordion "Debug" true fun () =>
                ;[
                    leptos.grid_pair
                        { class = "" }
                        ("JSON" |> leptos.text_fragment)
                        (json |> leptos.move_to_fragment fun json =>
                            json
                            |> leptos.resource_get
                            |> sm'.format_pretty
                            |> sm'.from_std_string
                            |> leptos.text_fragment
                            |> leptos.text_block_pre
                            |> leptos.element_to_fragment)
                    |> leptos.element_to_view


                    leptos.grid_pair
                        { class = "" }
                        ("Result Wrapper" |> leptos.text_fragment)
                        (result_wrapper |> leptos.move_to_fragment fun result_wrapper =>
                            result_wrapper
                            |> leptos.memo_get
                            |> resultm.unbox
                            |> resultm.map (am.map result_wrapper_unbox)
                            |> sm'.format_pretty
                            |> sm'.from_std_string
                            |> leptos.text_fragment
                            |> leptos.text_block_pre
                            |> leptos.element_to_fragment)
                    |> leptos.element_to_view
                ]
                |> leptos.views_to_fragment
            |> leptos.element_to_view
        else ;[] |> leptos.views_to_view
    ]
