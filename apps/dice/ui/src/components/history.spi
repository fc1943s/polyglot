open rust_operators
open model.near.backend

inl types () =
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"reqwest_wasm::Response\")>] type reqwest_Response = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"reqwest_wasm::Error\")>] type reqwest_Error = class end"

nominal reqwest_response = $"reqwest_Response"
nominal reqwest_error = $"reqwest_Error"

inl new_request_get (url : string) : rust.pin (rust.box (rust.dyn' (rust.future (resultm.result' reqwest_response reqwest_error)))) =
    inl url = join url
    inl url = url |> sm'.to_std_string
    inl url = join url
    !\($'"Box::pin(reqwest_wasm::Client::builder().build().map_err(|err| err.to_string())?.get(!url).send())"')

inl response_text (response : reqwest_response) : rust.pin (rust.box (rust.dyn' (rust.future (resultm.result' rust.std_string reqwest_error)))) =
    !\($'"Box::pin(reqwest_wasm::Response::text(!response))"')

inl date_time_from_timestamp forall t {int}. (timestamp : t) : option rust.naive_date_time =
    inl timestamp = join timestamp
    inl result : optionm'.option' rust.naive_date_time =
        !\($'"chrono::NaiveDateTime::from_timestamp_millis(!timestamp.try_into().unwrap())"')
    result |> optionm'.unbox

inl transaction_render (transaction : transaction) : _ leptos.pre =
    inl block_timestamp = transaction.block_timestamp

    inl block_date =
        block_timestamp
        |> date_time_from_timestamp

    block_date
    |> sm'.format_pretty
    |> sm'.from_std_string
    |> leptos.text_fragment
    |> leptos.text_block_pre

inl render () =
    leptos.log $'"history.render ()"'

    inl global_state : state.global_state = leptos.use_context () |> optionm'.unwrap

    inl url_input = leptos.create_memo fun () =>
        leptos.log $'"history.render () / url_input create_memo"'

        inl id = "i574n.near"

        inl input_obj : rust.hash_map rust.std_string (rust.rc input_data') =
            ;[
                "0" |> sm'.to_std_string,
                IdInput { id = id |> sm'.to_std_string } |> input_data_box |> rust.new_rc

                "1" |> sm'.to_std_string,
                IdInput { id = id |> sm'.to_std_string } |> input_data_box |> rust.new_rc

                "2" |> sm'.to_std_string,
                TransactionListByAccountIdInput
                    {
                        account_id = id |> sm'.to_std_string
                        limit = 10
                        cursor = None
                    }
                |> input_data_box |> rust.new_rc
            ]
            |> mapm.from_array

        inl input_json : resultm.result' rust.std_string rust.json_error = !\($'"serde_json::to_string(&!input_obj)"')
        inl input_json = input_json |> resultm.unwrap'
        inl input : rust.js_string = !\($'"js_sys::encode_uri_component(&!input_json)"')
        input |> sm'.format

    inl url = leptos.create_memo fun () =>
        leptos.log $'"history.render () / url create_memo"'

        inl explorer_backend_host =
            leptos.rw_signal_get_untracked global_state.state .explorer_backend_host
            |> leptos.rw_signal_get

        inl url_input = url_input |> leptos.memo_get

        inl url : string = $'"https://" + string !explorer_backend_host + "/trpc/account.transactionsCount,contract.byId,transaction.listByAccountId?batch=1&input=" + string !url_input + ""'
        leptos.log $'"history.render () / url: " + !url + ""'
        url

    inl json : leptos.resource string (resultm.result' string string) =
        leptos.create_local_resource
            fun () => url |> leptos.memo_get
            fun url =>
                fun () =>
                    leptos.log $'"history.render () / json create_local_resource"'
                    url
                    |> new_request_get
                    |> async.await
                    |> resultm.map_error' sm'.format
                    |> resultm.try'
                    |> response_text
                    |> async.await
                    |> resultm.map_error' sm'.format
                    |> resultm.try'
                    |> sm'.from_std_string
                    |> Ok
                    |> resultm.box
                |> async.future_init 2 0

    inl result_wrapper : leptos.memo (resultm.result' (a i32 result_wrapper') string) =
        leptos.create_memo fun () =>
            leptos.log $'"history.render () / result_wrapper create_memo"'

            json
            |> leptos.resource_get
            |> optionm'.unbox
            |> optionm.map resultm.unbox
            |> resultm.flatten_option
            |> resultm.map fun json =>
                json
                |> sm'.deserialize
                |> resultm.map_error' sm'.format
                |> resultm.try'
                |> am'.from_vec
            |> resultm.box

    inl result_wrapper : rust.func0 (result (a i32 result_wrapper) string) =
        rust.move (fun () => result_wrapper |> leptos.memo_get) fun result_wrapper =>
            leptos.log $'"history.render () / result_wrapper move"'

            result_wrapper
            |> resultm.unbox
            |> resultm.map (am.map result_wrapper_unbox)

    inl transaction_list : rust.func0 (result transaction_list_by_account_id string) =
        rust.move (fun () => result_wrapper |> rust.func0_get) fun result_wrapper =>
            leptos.log $'"history.render () / transaction_list move"'

            result_wrapper
            |> resultm.map fun result =>
                result
                |> am.toList
                |> listm'.try_pick fun result =>
                    result.result
                    |> optionm.map fun result =>
                        match result.data with
                        | TransactionListByAccountId transaction_list_by_account_id =>
                            Some transaction_list_by_account_id
                        | _ => None
                    |> optionm'.flatten
                |> resultm.from_option
            |> resultm.flatten

    inl cursor : rust.func0 (result transaction_cursor string) =
        rust.move (fun () => transaction_list |> rust.func0_get) fun transaction_list =>
            leptos.log $'"history.render () / transaction_cursor move"'

            transaction_list
            |> resultm.map fun result =>
                result.cursor
                |> resultm.from_option
            |> resultm.flatten

    inl transactions : rust.func0 (result (array transaction) string) =
        rust.move (fun () => transaction_list |> rust.func0_get) fun transaction_list =>
            leptos.log $'"history.render () / transactions move"'

            transaction_list
            |> resultm.map fun result =>
                result.items

    ;[
        leptos.accordion "History" true fun () =>
            transactions |> leptos.move_to_fragment fun transactions =>
                match transactions |> rust.func0_get with
                | Ok transactions =>
                    leptos.for
                        transactions
                        (fun transaction => transaction.hash)
                        (transaction_render >> leptos.element_to_fragment)
                    |> leptos.view_to_fragment
                | Error error => $'"Error: " + string !error + ""' |> leptos.text_fragment
        |> leptos.element_to_view

        if leptos.rw_signal_get_untracked global_state.core_state .debug |> leptos.rw_signal_get then
            leptos.accordion "Debug" true fun () =>
                ;[
                    leptos.grid_pair
                        { class = "" }
                        ("Transaction List" |> leptos.text_fragment)
                        (transaction_list |> leptos.move_to_fragment fun transaction_list =>
                            transaction_list
                            |> rust.func0_get
                            |> sm'.format_pretty
                            |> sm'.from_std_string
                            |> leptos.text_fragment
                            |> leptos.text_block_pre
                            |> leptos.element_to_fragment)
                    |> leptos.element_to_view

                    leptos.grid_pair
                        { class = "" }
                        ("Result Wrapper" |> leptos.text_fragment)
                        (result_wrapper |> leptos.move_to_fragment fun result_wrapper =>
                            result_wrapper
                            |> rust.func0_get
                            |> sm'.format_pretty
                            |> sm'.from_std_string
                            |> leptos.text_fragment
                            |> leptos.text_block_pre
                            |> leptos.element_to_fragment)
                    |> leptos.element_to_view

                    leptos.grid_pair
                        { class = "" }
                        ("JSON" |> leptos.text_fragment)
                        (json |> leptos.move_to_fragment fun json =>
                            json
                            |> leptos.resource_get
                            |> sm'.format_pretty
                            |> sm'.from_std_string
                            |> leptos.text_fragment
                            |> leptos.text_block_pre
                            |> leptos.element_to_fragment)
                    |> leptos.element_to_view
                ]
                |> leptos.views_to_fragment
            |> leptos.element_to_view
        else ;[] |> leptos.views_to_view
    ]
