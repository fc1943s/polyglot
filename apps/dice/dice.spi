// // # dice (Polyglot)

// // ## sixth_power_sequence

inl sixth_power_sequence () =
    stream.iterate ((*) 6) 1

// // ## accumulate_dice_rolls

inl accumulate_dice_rolls (log : option (string -> ())) rolls power acc =
    inl rec body acc power rolls =
        match rolls with
        | _ when power < 0 =>
            log |> optionm'.iter ((|>) $"$\"accumulate_dice_rolls / power: {!power} / acc: {!acc}\"")
            Some (acc + 1, rolls)
        | [] => None
        | roll :: rest when roll > 1 =>
            inl coeff = sixth_power_sequence () |> stream.item power
            inl value = (roll - 1) * coeff
            log |> optionm'.iter ((|>) $"$\"accumulate_dice_rolls / power: {!power} / acc: {!acc} / roll: {!roll} / value: {!value}\""
            )
            loop (acc + value) (power - 1) rest
        | roll :: rest =>
            log |> optionm'.iter ((|>) $"$\"accumulate_dice_rolls / power: {!power} / acc: {!acc} / roll: {!roll}\"")
            loop acc (power - 1) rest
    and inl loop acc power rolls =
        if var_is rolls |> not
        then body acc power rolls
        else
            inl acc = dyn acc
            join body acc power rolls
    loop acc power rolls

// // ## roll_within_bounds

inl roll_within_bounds (log : option (string -> ())) max rolls =
    inl power = listm.length rolls - 1i64
    match accumulate_dice_rolls log rolls power 0 with
    | Some (result, _) when result >= 1 && result <= max => Some result
    | _ => None

// // ## calculate_dice_count

inl calculate_dice_count (log : option (string -> ())) max =
    inl rec body n p =
        if p > 0 && p < max
        then loop (n + 1) (p * 6)
        else
            log |> optionm'.iter ((|>) $"$\"calculate_dice_count / max: {!max} / n: {!n} / p: {!p}\"")
            n
    and inl loop n p =
        if var_is max |> not
        then body n p
        else
            inl n = dyn n
            inl p = dyn p
            join body n p
    if max = 1
    then 1
    else loop 0 1

// // ## roll_dice

inl roll_dice () : i32 =
    $"System.Random().Next (1, 7)"

// // ## rotate_number

inl rotate_number max n =
    (n - 1 + max) % max + 1

// // ## rotate_numbers

inl rotate_numbers max items =
    items |> stream.map (rotate_number max)

// // ## create_sequential_roller

inl create_sequential_roller list =
    inl s = list |> listm.rev |> listm.append list |> stream.from_list |> stream.memoize
    inl current_index = mut 0i32
    inl acc = mut 1
    inl len = mut -1
    let rec loop () =
        match s () |> stream.try_item *current_index with
        | Some item =>
            current_index <- *current_index + 1
            item
        | None =>
            if *len = -1
            then len <- *current_index
            acc <-
                if *acc >= *len
                then 1
                else *acc + 1
            current_index <- *acc - 1
            loop ()
    loop

// // ## roll_progressively

inl roll_progressively (log : option (string -> ())) roll reroll max =
    inl power = (calculate_dice_count log max) - 1i64
    let rec loop rolls size =
        if size < power + 1
        then loop (roll () :: rolls) (size + 1)
        else accumulate_dice_rolls log rolls power 0 |> function
            | Some (result, _) when result <= max => result
            | _ when reroll => loop (listm.init power (fun _ => roll ())) power
            | _ => loop (roll () :: rolls) (size + 1)
    loop [] 0

// // ## main

inl main () =
    let main () =
        inl rotate_numbers' : u64 -> stream.stream u64 -> stream.stream u64 = rotate_numbers
        inl create_sequential_roller' : (list u64 -> () -> u64) = create_sequential_roller
        inl roll_progressively' : (option (string -> ()) -> (() -> u64) -> bool -> u64 -> u64) = roll_progressively
        inl roll_within_bounds' : option (string -> ()) -> u64 -> list u64 -> option u64 = roll_within_bounds

        (rotate_numbers', create_sequential_roller', roll_progressively', roll_within_bounds')
        |> dyn
        |> ignore
    main ()
    $"let main _args = 0" : ()
