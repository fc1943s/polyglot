#!meta

{"kernelInfo":{"defaultKernelName":"fsharp","items":[]}}

#!fsharp

#!import ../../nbs/Core.dib
#!import ../../nbs/Testing.dib

#!fsharp

#r "nuget:FParsec"

#!fsharp

open FParsec

#!fsharp

type Block =
    {
        magic : string
        content : string
    }

#!fsharp

let magicMarker : Parser<string, unit> = pstring "#!"

#!fsharp

//// test

let input = "#!magic"
let result = run magicMarker input
result |> _equal (
    Success ("#!", (), Position ("", 2, 1, 3))
)

#!fsharp

//// test

let input = "##!magic"
let result = run magicMarker input
result |> _equal (
    Failure (
        $"Error in Ln: 1 Col: 1{nl}##!magic{nl}^{nl}Expecting: '#!'{nl}",
        ParserError (
            Position ("", 0, 1, 1),
            (),
            ErrorMessageList (ExpectedString "#!")
        ),
        ()
    )
)

#!fsharp

let magicCommand =
    magicMarker
    >>. manyTill anyChar newline
    |>> (String.Concat >> String.trim)

#!fsharp

//// test

let input = """#!magic

a"""
let result = run magicCommand input
result |> _equal (
    Success ("magic", (), Position ("", 8, 2, 1))
)

#!fsharp

//// test

let input = """ #!magic

a"""
let result = run magicCommand input
result |> _equal (
    Failure (
        $"Error in Ln: 1 Col: 1{nl} #!magic{nl}^{nl}Expecting: '#!'{nl}",
        ParserError (
            Position ("", 0, 1, 1),
            (),
            ErrorMessageList (ExpectedString "#!")
        ),
        ()
    )
)

#!fsharp

let content =
    (newline >>. magicMarker) <|> (eof >>. preturn "")
    |> attempt
    |> lookAhead
    |> manyTill anyChar
    |>> (String.Concat >> String.trim)

#!fsharp

//// test

let input = """#!magic


a


"""
let result = run content input
result |> _equal (
    Success ("""#!magic


a""", (), Position ("", 14, 7, 1))
)

#!fsharp

let block =
    pipe2
        magicCommand
        content
        (fun magic content ->
            {
                magic = magic
                content = content
            })

#!fsharp

//// test

let input = """#!magic


a


"""
let result = run block input
result |> _equal (
    Success (
        { magic = "magic"; content = "a" },
        (),
        Position ("", 14, 7, 1)
    )
)

#!fsharp

let blocks =
    skipMany newline
    >>. sepEndBy block (skipMany1 newline)

#!fsharp

//// test

let input =
    """#!magic1

a

\#!magic2

b

""" |> escapeCell
let result = run blocks input
result |> _equal (
    Success (
        [
            { magic = "magic1"; content = "a" }
            { magic = "magic2"; content = "b" }
        ],
        (),
        Position ("", 26, 9, 1)
    )
)

#!fsharp

let formatBlock kernel (block : Block) =
    match kernel, block with
    | _, { magic = "markdown"; content = content } ->
        content.Split [| '\n' |]
        |> Array.map (fun line -> line.Trim ())
        |> Array.map (function
            | "" -> "//"
            | line -> $"// {line}"
        )
        |> String.concat "\n"
    | "fsharp", { magic = "fsharp"; content = content } when
        (content.StartsWith "//// test"
        || content.StartsWith "//// ignore")
        |> not ->
            content.Split [| '\n' |]
            |> Array.filter (fun line -> line.StartsWith "#r" |> not)
            |> String.concat "\n"
    | _ -> ""

#!fsharp

//// test

let input =
    """#!markdown


a

b


\#!markdown


c


\#!fsharp


let a = 1""" |> escapeCell
let result =
    match run block input with
    | Success (block, _, _) ->
        formatBlock "fsharp" block
    | Failure (msg, _, _) ->
        failwith msg
result |> _equal """// a
//
// b"""

#!fsharp

let formatBlocks kernel blocks =
    blocks
    |> List.map (formatBlock kernel)
    |> List.filter (fun s -> s <> "")
    |> String.concat "\n\n"
    |> fun s -> s + "\n"

#!fsharp

//// test

let input =
    """#!markdown


a

b


\#!markdown


c


\#!fsharp


let a = 1""" |> escapeCell
let result =
    match run blocks input with
    | Success (blocks, _, _) ->
        formatBlocks "fsharp" blocks
    | Failure (msg, _, _) ->
        failwith msg
result |> _equal """// a
//
// b

// c

let a = 1
"""

#!fsharp

let run input =
    match run blocks input with
    | Success (result, _, _) -> Result.Ok result
    | Failure (errorMsg, _, _) -> Result.Error errorMsg

#!fsharp

let parseDibCode kernel file =
    let input = File.ReadAllText file
    match run input with
    | Result.Ok blocks ->
        blocks
        |> List.filter (fun block -> block.magic = kernel || block.magic = "markdown")
        |> formatBlocks kernel
    | Result.Error msg -> failwith msg

#!fsharp

let writeDibCode kernel file =
    printfn $"Parsing {file}"
    let output = parseDibCode kernel file
    let outputFileName =
        match kernel with
        | "fsharp" -> file.Replace (".dib", ".fs")
        | _ -> failwith "Unknown kernel"
    File.WriteAllText (outputFileName, output)

#!fsharp

//// test

let example1 =
    """#!meta

{"kernelInfo":{"defaultKernelName":"fsharp","items":[{"aliases":[],"name":"fsharp"},{"aliases":[],"name":"fsharp"}]}}

\#!fsharp

##r "nuget:Expecto"

\#!markdown

## ParserLibrary

\#!fsharp

open System

\#!markdown

### TextInput

\#!fsharp

type Position =
    {
        line : int
        column : int
    }"""
    |> escapeCell

printfn $"{example1}"

let blocks1 =
    run example1
    |> Result.toOption
    |> Option.get
blocks1

#!fsharp

//// test

blocks1
|> (formatBlocks "fsharp")
|> _equal """##r "nuget:Expecto"

// ## ParserLibrary

open System

// ### TextInput

type Position =
    {
        line : int
        column : int
    }
"""

#!fsharp

//// test

blocks1
|> (formatBlocks "markdown")
|> _equal """// ## ParserLibrary

// ### TextInput
"""

#!fsharp

//// test

match Environment.GetEnvironmentVariable "OUTPUT" with
| "" | null -> ()
| path when System.IO.File.Exists path -> path |> writeDibCode "fsharp"
| path when path.Contains ";" -> path.Split [| ';' |] |> Array.iter (writeDibCode "fsharp")
| _ -> System.IO.Path.Combine (System.IO.Directory.GetCurrentDirectory (), "DibParser.dib") |> writeDibCode "fsharp"
