#!meta

{"kernelInfo":{"defaultKernelName":"fsharp","items":[]}}

#!markdown

# Builder (Polyglot)

#!fsharp

#!import ../nbs/Testing.dib

#!fsharp

#r @"../../../../../../../.nuget/packages/fsharp.control.asyncseq/3.2.1/lib/netstandard2.1/FSharp.Control.AsyncSeq.dll"
#r @"../../../../../../../.nuget/packages/system.reactive/5.0.0/lib/net5.0/System.Reactive.dll"
#r @"../../../../../../../.nuget/packages/system.reactive.linq/6.0.1-preview.1/lib/netstandard2.0/System.Reactive.Linq.dll"
#r @"../../../../../../../.nuget/packages/argu/6.1.1/lib/netstandard2.0/Argu.dll"
#r @"../../../../../../../.nuget/packages/system.commandline/2.0.0-beta4.22272.1/lib/net6.0/System.CommandLine.dll"

#!fsharp

#!import ../nbs/Common.fs
#!import ../nbs/CommonFSharp.fs
#!import ../nbs/Async.fs
#!import ../nbs/AsyncSeq.fs
#!import ../nbs/Networking.fs
#!import ../nbs/Runtime.fs
#!import ../nbs/FileSystem.fs

#!fsharp

open Common
open FileSystem

#!markdown

## buildProject

#!fsharp

let buildProject path = async {
    let fullPath = path |> System.IO.Path.GetFullPath
    let fileDir = fullPath |> System.IO.Path.GetDirectoryName
    let extension = fullPath |> System.IO.Path.GetExtension

    let getLocals () = $"fullPath: {fullPath} / {getLocals ()}"
    trace Debug (fun () -> "buildProject") getLocals

    match extension with
    | ".fsproj" -> ()
    | _ -> failwith "Invalid project file"

    let! exitCode, _result =
        Runtime.executeWithOptionsAsync
            {
                Command = "dotnet build -c Release"
                CancellationToken = None
                OnLine = None
                WorkingDirectory = Some fileDir
            }

    return exitCode
}

#!markdown

## buildCode

#!fsharp

let buildCode packages modules path name code = async {
    let getLocals () = $"packages: {packages} / modules: {modules} / path: {path} / name: {name} / code.Length: {code |> String.length} / {getLocals ()}"
    trace Debug (fun () -> "buildCode") getLocals

    let targetPath = path </> "target"
    System.IO.Directory.CreateDirectory targetPath |> ignore

    let filePath = targetPath </> $"{name}.fs" |> System.IO.Path.GetFullPath
    do! code |> FileSystem.writeAllTextAsync filePath

    let repositoryRoot = path |> FileSystem.findParent ".paket" false

    let modulesCode =
        modules
        |> List.map (fun path -> $"""<Compile Include="{repositoryRoot </> path}" />""")
        |> String.concat "\n        "

    let fsprojPath = targetPath </> $"{name}.fsproj"
    let fsprojCode = $"""<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <LangVersion>preview</LangVersion>
        <RollForward>Major</RollForward>
        <TargetLatestRuntimePatch>true</TargetLatestRuntimePatch>
        <Version>0.0.1-alpha.1</Version>
        <OutputType>Exe</OutputType>
    </PropertyGroup>

    <ItemGroup>
        {modulesCode}
        <Compile Include="{filePath}" />
    </ItemGroup>

    <Import Project="{repositoryRoot}/.paket/Paket.Restore.targets" />
</Project>
"""
    do! fsprojCode |> FileSystem.writeAllTextAsync fsprojPath

    let paketReferencesCode =
        "FSharp.Core" :: packages
        |> String.concat "\n"

    do! paketReferencesCode |> FileSystem.writeAllTextAsync (targetPath </> "paket.references")

    return! fsprojPath |> buildProject
}

#!fsharp

//// test

let tempFolder = FileSystem.getSourceDirectory () </> "target/test"

"1 + 1"
|> buildCode [] [] tempFolder "test"
|> Async.runWithTimeoutStrict 20000
|> _equal (Some 0)

#!fsharp

//// test

let tempFolder = FileSystem.getSourceDirectory () </> "target/test"

"1 + a"
|> buildCode [] [] tempFolder "test"
|> Async.runWithTimeoutStrict 20000
|> _equal (Some 1)

#!markdown

## buildFile

#!fsharp

let buildFile packages modules path = async {
    let fullPath = path |> System.IO.Path.GetFullPath
    let dir = fullPath |> System.IO.Path.GetDirectoryName
    let fileName = fullPath |> System.IO.Path.GetFileNameWithoutExtension
    let! code = fullPath |> FileSystem.readAllTextAsync

    let code = System.Text.RegularExpressions.Regex.Replace (
        code,
        @"( *)(let\s+main\s+.*?\s*=)",
        fun m -> m.Groups.[1].Value + "[<EntryPoint>]\n" + m.Groups.[1].Value + m.Groups.[2].Value
    )

    return! code |> buildCode packages modules dir fileName
}

#!markdown

## Arguments

#!fsharp

[<RequireQualifiedAccess>]
type Arguments =
    | [<Argu.ArguAttributes.MainCommand; Argu.ArguAttributes.ExactlyOnce>] Path of path : string
    | [<Argu.ArguAttributes.Unique>] Packages of packages : string list
    | [<Argu.ArguAttributes.Unique>] Modules of modules : string list

    interface Argu.IArgParserTemplate with
        member s.Usage =
            match s with
            | Path _ -> nameof Arguments.Path
            | Packages _ -> nameof Arguments.Packages
            | Modules _ -> nameof Arguments.Modules

#!markdown

## main

#!fsharp

let main args =
    let argsMap = args |> Runtime.parseArgsMap<Arguments>

    let path =
        match argsMap.[nameof Arguments.Path] with
        | [ Arguments.Path path ] -> Some path
        | _ -> None
        |> Option.get

    let packages =
        match argsMap |> Map.tryFind (nameof Arguments.Packages) with
        | Some [ Arguments.Packages packages ] -> packages
        | _ -> []

    let modules =
        match argsMap |> Map.tryFind (nameof Arguments.Modules) with
        | Some [ Arguments.Modules modules ] -> modules
        | _ -> []

    path
    |> buildFile packages modules
    |> Async.runWithTimeout 30000
    |> function
        | Some exitCode -> exitCode
        | None -> 1

#!fsharp

//// test

let args =
    System.Environment.GetEnvironmentVariable "ARGS"
    |> Runtime.splitArgs
    |> Seq.toArray

match args with
| [||] -> 0
| args -> if main args = 0 then 0 else failwith "main failed"
