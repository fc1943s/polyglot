#!meta

{"kernelInfo":{"defaultKernelName":"fsharp","items":[]}}

#!markdown

# Builder (Polyglot)

#!fsharp

#!import ../nbs/Testing.dib

#!fsharp

#r @"../../../../../../../.nuget/packages/fsharp.control.asyncseq/3.2.1/lib/netstandard2.1/FSharp.Control.AsyncSeq.dll"
#r @"../../../../../../../.nuget/packages/system.reactive/5.0.0/lib/net5.0/System.Reactive.dll"
#r @"../../../../../../../.nuget/packages/system.reactive.linq/6.0.1-preview.1/lib/netstandard2.0/System.Reactive.Linq.dll"
#r @"../../../../../../../.nuget/packages/argu/6.1.1/lib/netstandard2.0/Argu.dll"
#r @"../../../../../../../.nuget/packages/system.commandline/2.0.0-beta4.22272.1/lib/net6.0/System.CommandLine.dll"
#r @"../../../../../../../.nuget/packages/asyncio/0.1.69/lib/netstandard2.0/AsyncIO.dll"
#r @"../../../../../../../.nuget/packages/netmq/4.0.1.12/lib/netstandard2.1/NetMQ.dll"

#!fsharp

#!import ../nbs/Common.fs
#!import ../nbs/Async.fs
#!import ../nbs/AsyncSeq.fs
#!import ../nbs/Networking.fs
#!import ../nbs/Runtime.fs
#!import ../nbs/FileSystem.fs

#!fsharp

open Common
open FileSystem

#!fsharp

let build path = async {
    let fullPath = path |> System.IO.Path.GetFullPath
    let dir = fullPath |> System.IO.Path.GetDirectoryName
    let fileName = fullPath |> System.IO.Path.GetFileNameWithoutExtension
    let extension = fullPath |> System.IO.Path.GetExtension

    let getLocals () = $"dir: {dir} / fileName: {fileName} / extension: {extension} / {getLocals ()}"
    trace Debug (fun () -> "build") getLocals

    let targetPath =
        dir </> "target"

    let fsprojPath =
        targetPath </> $"{fileName}.fsproj"

    let repoRoot =
        let rec loop dir =
            if dir </> ".paket" |> System.IO.Directory.Exists
            then dir
            else dir |> System.IO.Directory.GetParent |> fun x -> x.FullName |> loop
        loop dir

    let fsprojCode = $"""<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <LangVersion>preview</LangVersion>
        <RollForward>Major</RollForward>
        <TargetLatestRuntimePatch>true</TargetLatestRuntimePatch>
        <Version>0.0.1-alpha.1</Version>
        <OutputType>Exe</OutputType>
    </PropertyGroup>

    <ItemGroup>
        <Compile Include="{repoRoot}/nbs/Common.fs" />
        <Compile Include="{repoRoot}/nbs/Async.fs" />
        <Compile Include="{repoRoot}/nbs/AsyncSeq.fs" />
        <Compile Include="{repoRoot}/nbs/Runtime.fs" />
        <Compile Include="{repoRoot}/nbs/FileSystem.fs" />
        <Compile Include="{fullPath}" />
    </ItemGroup>

    <Import Project="{repoRoot}/.paket/Paket.Restore.targets" />
</Project>
"""
    System.IO.Directory.CreateDirectory targetPath |> ignore

    let paketReferencesCode = $"FSharp.Core

Argu
FParsec
FSharp.Control.AsyncSeq
System.CommandLine
System.Reactive.Linq
"

    do! System.IO.File.WriteAllTextAsync (targetPath </> "paket.references", paketReferencesCode) |> Async.AwaitTask

    do! System.IO.File.WriteAllTextAsync (fsprojPath, fsprojCode) |> Async.AwaitTask

    let! exitCode, _result =
        Runtime.executeWithOptionsAsync
            {
                Command = "dotnet build -c Release"
                CancellationToken = None
                OnLine = None
                WorkingDirectory = Some targetPath
            }

    return exitCode
}

#!fsharp

[<RequireQualifiedAccess>]
type Arguments =
    | [<Argu.ArguAttributes.MainCommand; Argu.ArguAttributes.ExactlyOnce; Argu.ArguAttributes.Last>]
        Paths of paths : string list

    interface Argu.IArgParserTemplate with
        member s.Usage =
            match s with
            | Paths _ -> nameof Arguments.Paths

#!fsharp

[<EntryPoint>]
let main args =
    let paths =
        match args |> Runtime.parseArgs<Arguments> with
        | [ Arguments.Paths paths ] -> paths
        | _ -> []

    paths
    |> List.map build
    |> Async.Parallel
    |> Async.RunSynchronously
    |> Array.sum

#!fsharp

//// test

let args =
    System.Environment.GetEnvironmentVariable "ARGS"
    |> Runtime.splitArgs
    |> Seq.toArray

match args with
| [||] -> 0
| args -> main args
